#!/bin/bash
set -euo pipefail

# ============================================================================
# PROSODY MANAGER - Unified CLI Tool
# ============================================================================
# Comprehensive management tool for Prosody XMPP Server
# Consolidates multiple management scripts into a single interface

readonly VERSION="0.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR
PROJECT_DIR="$SCRIPT_DIR"
readonly PROJECT_DIR
readonly CONFIG_DIR="$PROJECT_DIR/config"
readonly DOCKER_DIR="$PROJECT_DIR/docker"

# ============================================================================
# COLORS AND FORMATTING
# ============================================================================

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        echo -e "${CYAN}[DEBUG]${NC} $1"
    fi
}

# ============================================================================
# INTERACTIVE MODE FUNCTIONS
# ============================================================================

# Interactive confirmation with default
confirm() {
    local prompt="$1"
    local default="${2:-N}"
    local response

    if [[ "$default" == "Y" || "$default" == "y" ]]; then
        read -r -p "$prompt (Y/n): " -n 1 -r response
    else
        read -r -p "$prompt (y/N): " -n 1 -r response
    fi
    echo

    if [[ -z "$response" ]]; then
        response="$default"
    fi

    [[ "$response" =~ ^[Yy]$ ]]
}

# Interactive menu selection
select_option() {
    local prompt="$1"
    shift
    local options=("$@")

    echo "$prompt"
    for i in "${!options[@]}"; do
        echo "  $((i + 1)). ${options[i]}"
    done

    local choice
    while true; do
        read -r -p "Select option (1-${#options[@]}): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le "${#options[@]}" ]]; then
            echo "${options[$((choice - 1))]}"
            return 0
        else
            echo "Invalid selection. Please choose 1-${#options[@]}."
        fi
    done
}

# Interactive input with validation
input_with_validation() {
    local prompt="$1"
    local validation_func="$2"
    local error_msg="$3"
    local value

    while true; do
        read -r -p "$prompt: " value
        if [[ -n "$value" ]] && "$validation_func" "$value"; then
            echo "$value"
            return 0
        else
            echo "$error_msg"
        fi
    done
}

# Interactive setup wizard
interactive_setup() {
    echo -e "${BOLD}🚀 Prosody XMPP Server Setup Wizard${NC}"
    echo "This wizard will guide you through setting up your XMPP server."
    echo

    # Check if .env exists
    if [[ -f "$PROJECT_DIR/.env" ]]; then
        if ! confirm "An .env file already exists. Do you want to reconfigure it?"; then
            log_info "Setup cancelled. Using existing configuration."
            return 0
        fi
    fi

    # Domain configuration
    echo -e "${BOLD}Step 1: Domain Configuration${NC}"
    local domain
    domain=$(input_with_validation "Enter your XMPP domain (e.g., chat.example.com)" \
        "validate_domain" \
        "Please enter a valid domain name (e.g., chat.example.com)")

    # Admin user
    echo -e "${BOLD}Step 2: Administrator Account${NC}"
    local admin_user
    admin_user=$(input_with_validation "Enter admin email (e.g., admin@$domain)" \
        "validate_email" \
        "Please enter a valid email address")

    # Database configuration
    echo -e "${BOLD}Step 3: Database Configuration${NC}"
    local db_password
    read -s -p "Enter PostgreSQL password (will be hidden): " db_password
    echo

    # Certificate configuration
    echo -e "${BOLD}Step 4: Certificate Configuration${NC}"
    local cert_method
    cert_method=$(select_option "Choose certificate method:" \
        "Let's Encrypt (recommended for production)" \
        "Self-signed (for development/testing)")

    local cloudflare_token=""
    if [[ "$cert_method" == "Let's Encrypt"* ]]; then
        echo "For Let's Encrypt with Cloudflare DNS, you'll need a Cloudflare API token."
        read -p "Enter Cloudflare API token (or press Enter to skip): " cloudflare_token
    fi

    # Environment selection
    echo -e "${BOLD}Step 5: Environment Configuration${NC}"
    local environment
    environment=$(select_option "Choose environment type:" \
        "Production" \
        "Development")

    # Generate .env file
    echo -e "${BOLD}Step 6: Generating Configuration${NC}"
    generate_env_file "$domain" "$admin_user" "$db_password" "$cert_method" "$cloudflare_token" "$environment"

    echo -e "${BOLD}✅ Setup Complete!${NC}"
    echo
    echo "Next steps:"
    echo "1. Review the generated .env file"
    echo "2. Run: prosody-manager deploy up"
    echo "3. Create your admin user: prosody-manager prosodyctl adduser $admin_user"
    echo
}

generate_env_file() {
    local domain="$1"
    local admin_user="$2"
    local db_password="$3"
    local cert_method="$4"
    local cloudflare_token="$5"
    local environment="$6"

    local env_file="$PROJECT_DIR/.env"

    cat > "$env_file" << EOF
# Prosody XMPP Server Configuration
# Generated by prosody-manager setup wizard

# Domain Configuration
PROSODY_DOMAIN=$domain
PROSODY_ADMINS=$admin_user

# Database Configuration
POSTGRES_PASSWORD=$db_password
POSTGRES_USER=prosody
POSTGRES_DB=prosody

# Certificate Configuration
EOF

    if [[ "$cert_method" == "Let's Encrypt"* ]] && [[ -n "$cloudflare_token" ]]; then
        cat >> "$env_file" << EOF
CLOUDFLARE_API_TOKEN=$cloudflare_token
CERT_EMAIL=$admin_user
EOF
    fi

    if [[ "$environment" == "Development" ]]; then
        cat >> "$env_file" << EOF

# Development Settings
DEBUG=true
PROSODY_LOG_LEVEL=debug
EOF
    fi

    log_success "Configuration saved to .env"
}

# Interactive deployment wizard
interactive_deploy() {
    echo -e "${BOLD}🚀 Deployment Wizard${NC}"
    echo "This wizard will guide you through deploying your XMPP server."
    echo

    # Environment validation
    if ! validate_environment > /dev/null 2>&1; then
        log_error "Environment validation failed. Please fix the issues first."
        validate_environment
        return "$EXIT_CONFIG_ERROR"
    fi

    # Deployment mode selection
    local deploy_mode
    deploy_mode=$(select_option "Choose deployment mode:" \
        "Full deployment (all services)" \
        "Minimal deployment (Prosody only)" \
        "Development deployment")

    # Pre-deployment checks
    echo -e "${BOLD}Pre-deployment Checks${NC}"

    # Check if services are already running
    if docker compose -f "$DOCKER_DIR/docker-compose.yml" ps | grep -q "Up"; then
        if confirm "Some services are already running. Stop them first?"; then
            log_info "Stopping existing services..."
            docker compose -f "$DOCKER_DIR/docker-compose.yml" down
        fi
    fi

    # Confirm deployment
    echo -e "${BOLD}Ready to Deploy${NC}"
    echo "Mode: $deploy_mode"
    echo "Domain: ${PROSODY_DOMAIN:-$(grep PROSODY_DOMAIN .env 2> /dev/null | cut -d'=' -f2)}"
    echo

    if ! confirm "Proceed with deployment?" "Y"; then
        log_info "Deployment cancelled"
        return 0
    fi

    # Execute deployment
    case "$deploy_mode" in
        "Full deployment"*)
            deploy_up "full"
            ;;
        "Minimal deployment"*)
            deploy_up "minimal"
            ;;
        "Development deployment"*)
            if [[ -f "$DOCKER_DIR/docker-compose.dev.yml" ]]; then
                log_info "Starting development deployment..."
                docker compose -f "$DOCKER_DIR/docker-compose.dev.yml" up -d
            else
                deploy_up "full"
            fi
            ;;
    esac

    # Post-deployment setup
    echo -e "${BOLD}Post-deployment Setup${NC}"
    if confirm "Would you like to create an admin user now?"; then
        interactive_user_creation
    fi

    if confirm "Would you like to run a health check?"; then
        health_check
    fi
}

# Interactive user creation
interactive_user_creation() {
    echo -e "${BOLD}👤 User Creation Wizard${NC}"

    local email
    email=$(input_with_validation "Enter user email" \
        "validate_email" \
        "Please enter a valid email address")

    echo "Choose password method:"
    local pwd_method
    pwd_method=$(select_option "Password method:" \
        "Enter password now" \
        "Prompt for password during creation")

    case "$pwd_method" in
        "Enter password now")
            local password
            read -s -p "Enter password: " password
            echo
            prosodyctl_command "adduser" "$email" "$password"
            ;;
        *)
            prosodyctl_command "adduser" "$email"
            ;;
    esac
}

# Interactive backup wizard
interactive_backup() {
    echo -e "${BOLD}💾 Backup Wizard${NC}"

    local action
    action=$(select_option "Choose backup action:" \
        "Create new backup" \
        "Restore from backup" \
        "List existing backups")

    case "$action" in
        "Create new backup")
            local backup_name
            read -r -p "Enter backup name (or press Enter for auto-generated): " backup_name

            if [[ -n "$backup_name" ]] && ! validate_backup_name "$backup_name"; then
                log_error "Invalid backup name. Using auto-generated name."
                backup_name=""
            fi

            create_backup "$backup_name"
            ;;
        "Restore from backup")
            list_backups
            echo
            local backup_file
            read -r -p "Enter full path to backup file: " backup_file

            if [[ -f "$backup_file" ]]; then
                restore_backup "$backup_file"
            else
                log_error "Backup file not found: $backup_file"
            fi
            ;;
        "List existing backups")
            list_backups
            ;;
    esac
}

# ============================================================================
# VALIDATION AND ERROR HANDLING FUNCTIONS
# ============================================================================

# Enhanced error handling with exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_INVALID_ARGS=2
readonly EXIT_MISSING_DEPENDENCY=3
readonly EXIT_CONFIG_ERROR=4
readonly EXIT_NETWORK_ERROR=5
readonly EXIT_PERMISSION_ERROR=6

# Validation functions
validate_domain() {
    local domain="$1"
    if [[ -z "$domain" ]]; then
        return 1
    fi

    # Basic domain validation regex
    if [[ ! "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        return 1
    fi

    return 0
}

validate_email() {
    local email="$1"
    if [[ -z "$email" ]]; then
        return 1
    fi

    # Basic email validation
    if [[ ! "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        return 1
    fi

    return 0
}

validate_module_name() {
    local module="$1"
    if [[ -z "$module" ]]; then
        return 1
    fi

    # Module name should be alphanumeric with underscores
    if [[ ! "$module" =~ ^mod_[a-zA-Z0-9_]+$ ]] && [[ ! "$module" =~ ^[a-zA-Z0-9_]+$ ]]; then
        return 1
    fi

    return 0
}

validate_backup_name() {
    local name="$1"
    if [[ -z "$name" ]]; then
        return 1
    fi

    # Backup name should be safe for filesystem
    if [[ ! "$name" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        return 1
    fi

    return 0
}

# Enhanced error reporting with actionable guidance
error_with_guidance() {
    local error_msg="$1"
    local guidance="$2"
    local exit_code="${3:-$EXIT_GENERAL_ERROR}"

    log_error "$error_msg"
    if [[ -n "$guidance" ]]; then
        echo -e "${YELLOW}💡 Suggestion:${NC} $guidance"
    fi

    return "$exit_code"
}

# Environment validation
validate_environment() {
    local errors=0

    log_info "Validating environment..."

    # Check required commands
    local required_commands=("docker" "docker-compose")
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "$cmd"; then
            error_with_guidance "Required command not found: $cmd" \
                "Install Docker and Docker Compose: https://docs.docker.com/get-docker/" \
                "$EXIT_MISSING_DEPENDENCY"
            ((errors++))
        fi
    done

    # Check Docker daemon
    if command_exists docker && ! docker info > /dev/null 2>&1; then
        error_with_guidance "Docker daemon is not running" \
            "Start Docker daemon: sudo systemctl start docker" \
            "$EXIT_GENERAL_ERROR"
        ((errors++))
    fi

    # Check project structure
    local required_dirs=("$CONFIG_DIR" "$DOCKER_DIR")
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            error_with_guidance "Required directory not found: $dir" \
                "Ensure you're running from the project root directory" \
                "$EXIT_CONFIG_ERROR"
            ((errors++))
        fi
    done

    # Check .env file
    if [[ ! -f "$PROJECT_DIR/.env" ]]; then
        log_warn "No .env file found"
        if [[ -f "$PROJECT_DIR/.env.example" ]]; then
            echo -e "${YELLOW}💡 Suggestion:${NC} Copy .env.example to .env and configure it"
            echo "  cp .env.example .env"
        fi
    else
        validate_env_file
    fi

    if [[ $errors -gt 0 ]]; then
        log_error "Environment validation failed with $errors error(s)"
        return "$EXIT_CONFIG_ERROR"
    fi

    log_success "Environment validation passed"
    return "$EXIT_SUCCESS"
}

validate_env_file() {
    local env_file="$PROJECT_DIR/.env"
    local warnings=0

    log_debug "Validating .env file..."

    # Check for required variables
    local required_vars=("PROSODY_DOMAIN" "POSTGRES_PASSWORD")
    for var in "${required_vars[@]}"; do
        if ! grep -q "^${var}=" "$env_file"; then
            log_warn "Missing required environment variable: $var"
            ((warnings++))
        fi
    done

    # Validate domain if present
    if grep -q "^PROSODY_DOMAIN=" "$env_file"; then
        local domain
        domain=$(grep "^PROSODY_DOMAIN=" "$env_file" | cut -d'=' -f2 | tr -d '"' | tr -d "'")
        if ! validate_domain "$domain"; then
            log_warn "Invalid domain format in PROSODY_DOMAIN: $domain"
            ((warnings++))
        fi
    fi

    if [[ $warnings -gt 0 ]]; then
        log_warn "Environment file has $warnings warning(s)"
        echo -e "${YELLOW}💡 Suggestion:${NC} Review and fix .env file configuration"
    fi
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

command_exists() {
    command -v "$1" > /dev/null 2>&1
}

is_docker_environment() {
    [[ -f /.dockerenv ]] || grep -q docker /proc/1/cgroup 2> /dev/null
}

get_container_name() {
    if is_docker_environment; then
        echo "prosody"
    else
        # Dynamically detect the correct container name
        local container_name

        # Try different possible container names in order of preference
        for name in "xmpp-prosody-dev" "xmpp-prosody-1" "xmpp-prosody"; do
            if docker ps --format "{{.Names}}" | grep -q "^${name}$"; then
                echo "$name"
                return 0
            fi
        done

        # Fallback: find any running container with prosody in the name
        container_name=$(docker ps --format "{{.Names}}" | grep prosody | head -1)
        if [[ -n "$container_name" ]]; then
            echo "$container_name"
            return 0
        fi

        # Last resort: default name
        echo "xmpp-prosody-1"
    fi
}

run_in_container() {
    local container_name
    container_name=$(get_container_name)

    if is_docker_environment; then
        # Already in container, run directly
        "$@"
    else
        # Run in container
        docker exec -it "$container_name" "$@"
    fi
}

# ============================================================================
# PROSODYCTL MANAGEMENT
# ============================================================================

prosodyctl_command() {
    local cmd="$1"
    shift

    case "$cmd" in
        "adduser" | "user")
            if [[ $# -lt 1 ]]; then
                error_with_guidance "Missing required argument: user@domain" \
                    "Usage: prosody-manager prosodyctl adduser <user@domain> [password]" \
                    "$EXIT_INVALID_ARGS"
                return "$EXIT_INVALID_ARGS"
            fi

            local user="$1"
            local password="${2:-}"

            # Validate email format
            if ! validate_email "$user"; then
                error_with_guidance "Invalid email format: $user" \
                    "Email should be in format: username@domain.com" \
                    "$EXIT_INVALID_ARGS"
                return "$EXIT_INVALID_ARGS"
            fi

            log_info "Adding user: $user"
            if [[ -z "$password" ]]; then
                if ! run_in_container prosodyctl adduser "$user"; then
                    error_with_guidance "Failed to add user: $user" \
                        "Check if Prosody is running and the domain is configured" \
                        "$EXIT_GENERAL_ERROR"
                    return "$EXIT_GENERAL_ERROR"
                fi
            else
                if ! echo "$password" | run_in_container prosodyctl adduser "$user"; then
                    error_with_guidance "Failed to add user: $user" \
                        "Check if Prosody is running and the domain is configured" \
                        "$EXIT_GENERAL_ERROR"
                    return "$EXIT_GENERAL_ERROR"
                fi
            fi
            log_success "User $user added successfully"
            ;;
        "deluser")
            if [[ $# -lt 1 ]]; then
                error_with_guidance "Missing required argument: user@domain" \
                    "Usage: prosody-manager prosodyctl deluser <user@domain>" \
                    "$EXIT_INVALID_ARGS"
                return "$EXIT_INVALID_ARGS"
            fi

            local user="$1"

            # Validate email format
            if ! validate_email "$user"; then
                error_with_guidance "Invalid email format: $user" \
                    "Email should be in format: username@domain.com" \
                    "$EXIT_INVALID_ARGS"
                return "$EXIT_INVALID_ARGS"
            fi

            log_warn "Deleting user: $user"
            echo -e "${YELLOW}This action cannot be undone.${NC}"
            read -r -p "Are you sure you want to delete user $user? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "User deletion cancelled"
                return 0
            fi

            if ! run_in_container prosodyctl deluser "$user"; then
                error_with_guidance "Failed to delete user: $user" \
                    "Check if the user exists and Prosody is running" \
                    "$EXIT_GENERAL_ERROR"
                return "$EXIT_GENERAL_ERROR"
            fi
            log_success "User $user deleted successfully"
            ;;
        "passwd")
            if [[ $# -lt 1 ]]; then
                error_with_guidance "Missing required argument: user@domain" \
                    "Usage: prosody-manager prosodyctl passwd <user@domain> [password]" \
                    "$EXIT_INVALID_ARGS"
                return "$EXIT_INVALID_ARGS"
            fi

            local user="$1"
            local password="${2:-}"

            # Validate email format
            if ! validate_email "$user"; then
                error_with_guidance "Invalid email format: $user" \
                    "Email should be in format: username@domain.com" \
                    "$EXIT_INVALID_ARGS"
                return "$EXIT_INVALID_ARGS"
            fi

            log_info "Changing password for user: $user"
            if [[ -z "$password" ]]; then
                if ! run_in_container prosodyctl passwd "$user"; then
                    error_with_guidance "Failed to change password for user: $user" \
                        "Check if the user exists and Prosody is running" \
                        "$EXIT_GENERAL_ERROR"
                    return "$EXIT_GENERAL_ERROR"
                fi
            else
                if ! echo "$password" | run_in_container prosodyctl passwd "$user"; then
                    error_with_guidance "Failed to change password for user: $user" \
                        "Check if the user exists and Prosody is running" \
                        "$EXIT_GENERAL_ERROR"
                    return "$EXIT_GENERAL_ERROR"
                fi
            fi
            log_success "Password changed for user: $user"
            ;;
        "status")
            if ! run_in_container prosodyctl status; then
                error_with_guidance "Failed to get Prosody status" \
                    "Check if Prosody container is running: docker ps" \
                    "$EXIT_GENERAL_ERROR"
                return "$EXIT_GENERAL_ERROR"
            fi
            ;;
        "reload")
            log_info "Reloading Prosody configuration..."
            if ! run_in_container prosodyctl reload; then
                error_with_guidance "Failed to reload Prosody configuration" \
                    "Check configuration syntax: prosody-manager health config" \
                    "$EXIT_CONFIG_ERROR"
                return "$EXIT_CONFIG_ERROR"
            fi
            log_success "Prosody configuration reloaded"
            ;;
        "restart")
            if is_docker_environment; then
                error_with_guidance "Cannot restart from inside container" \
                    "Use 'docker compose restart prosody' from the host" \
                    "$EXIT_GENERAL_ERROR"
                return "$EXIT_GENERAL_ERROR"
            else
                log_info "Restarting Prosody service..."
                if ! docker compose -f "$DOCKER_DIR/docker-compose.yml" restart prosody; then
                    error_with_guidance "Failed to restart Prosody service" \
                        "Check Docker Compose configuration and service status" \
                        "$EXIT_GENERAL_ERROR"
                    return "$EXIT_GENERAL_ERROR"
                fi
                log_success "Prosody service restarted"
            fi
            ;;
        "cert")
            local subcmd="${1:-list}"
            shift || true

            case "$subcmd" in
                "import")
                    if [[ $# -lt 1 ]]; then
                        error_with_guidance "Missing required argument: domain" \
                            "Usage: prosody-manager prosodyctl cert import <domain> [cert_path]" \
                            "$EXIT_INVALID_ARGS"
                        return "$EXIT_INVALID_ARGS"
                    fi

                    local domain="$1"
                    if ! validate_domain "$domain"; then
                        error_with_guidance "Invalid domain format: $domain" \
                            "Domain should be in format: example.com" \
                            "$EXIT_INVALID_ARGS"
                        return "$EXIT_INVALID_ARGS"
                    fi

                    if ! run_in_container prosodyctl cert import "$@"; then
                        error_with_guidance "Failed to import certificate for domain: $domain" \
                            "Check certificate file permissions and format" \
                            "$EXIT_GENERAL_ERROR"
                        return "$EXIT_GENERAL_ERROR"
                    fi
                    ;;
                "generate")
                    if [[ $# -lt 1 ]]; then
                        error_with_guidance "Missing required argument: domain" \
                            "Usage: prosody-manager prosodyctl cert generate <domain>" \
                            "$EXIT_INVALID_ARGS"
                        return "$EXIT_INVALID_ARGS"
                    fi

                    local domain="$1"
                    if ! validate_domain "$domain"; then
                        error_with_guidance "Invalid domain format: $domain" \
                            "Domain should be in format: example.com" \
                            "$EXIT_INVALID_ARGS"
                        return "$EXIT_INVALID_ARGS"
                    fi

                    if ! run_in_container prosodyctl cert generate "$@"; then
                        error_with_guidance "Failed to generate certificate for domain: $domain" \
                            "Check OpenSSL installation and write permissions" \
                            "$EXIT_GENERAL_ERROR"
                        return "$EXIT_GENERAL_ERROR"
                    fi
                    ;;
                "list" | *)
                    if ! run_in_container prosodyctl cert list; then
                        error_with_guidance "Failed to list certificates" \
                            "Check if certificate directory exists and is readable" \
                            "$EXIT_GENERAL_ERROR"
                        return "$EXIT_GENERAL_ERROR"
                    fi
                    ;;
            esac
            ;;
        *)
            log_info "Running prosodyctl command: $cmd"
            if ! run_in_container prosodyctl "$cmd" "$@"; then
                error_with_guidance "prosodyctl command failed: $cmd" \
                    "Check 'prosody-manager prosodyctl --help' for available commands" \
                    "$EXIT_GENERAL_ERROR"
                return "$EXIT_GENERAL_ERROR"
            fi
            ;;
    esac
}

# ============================================================================
# HEALTH CHECK FUNCTIONS
# ============================================================================

health_check() {
    local check_type="${1:-all}"
    local exit_code=0

    log_info "Running Prosody health check..."

    case "$check_type" in
        "process" | "all")
            if ! check_process; then
                exit_code=1
            fi
            ;;
    esac

    case "$check_type" in
        "ports" | "all")
            if ! check_ports; then
                exit_code=1
            fi
            ;;
    esac

    case "$check_type" in
        "config" | "all")
            if ! check_config; then
                exit_code=1
            fi
            ;;
    esac

    case "$check_type" in
        "certs" | "certificates" | "all")
            if ! check_certificates_health; then
                exit_code=1
            fi
            ;;
    esac

    if [[ $exit_code -eq 0 ]]; then
        log_success "All health checks passed"
    else
        log_error "Some health checks failed"
    fi

    return $exit_code
}

check_process() {
    log_info "Checking Prosody process..."

    if run_in_container prosodyctl status > /dev/null 2>&1; then
        log_success "Prosody is running"
        return 0
    else
        log_error "Prosody process not running"
        return 1
    fi
}

check_ports() {
    local ports=(5222 5269 5280)
    local failed=0

    log_info "Checking port availability..."

    for port in "${ports[@]}"; do
        if run_in_container ss -tlnp | grep -q ":$port "; then
            log_success "Port $port is listening"
        else
            log_error "Port $port is not listening"
            ((failed++))
        fi
    done

    return $failed
}

check_config() {
    log_info "Checking configuration..."

    if run_in_container prosodyctl check config > /dev/null 2>&1; then
        log_success "Configuration is valid"
        return 0
    else
        log_error "Configuration validation failed"
        run_in_container prosodyctl check config
        return 1
    fi
}

check_certificates_health() {
    local domain="${PROSODY_DOMAIN:-localhost}"
    local warning_days=30
    local critical_days=7
    local failed=0

    log_info "Checking certificates for domain: $domain"

    # Check if certificate exists
    if ! run_in_container test -f "/etc/prosody/certs/$domain.crt"; then
        log_error "Certificate not found for domain: $domain"
        return 1
    fi

    # Check certificate expiry
    local expiry_date
    if expiry_date=$(run_in_container openssl x509 -in "/etc/prosody/certs/$domain.crt" -noout -enddate 2> /dev/null | cut -d= -f2); then
        local expiry_epoch
        expiry_epoch=$(date -d "$expiry_date" +%s)
        local current_epoch
        current_epoch=$(date +%s)
        local days_until_expiry=$(((expiry_epoch - current_epoch) / 86400))

        if [[ $days_until_expiry -lt $critical_days ]]; then
            log_error "Certificate expires in $days_until_expiry days (critical)"
            failed=1
        elif [[ $days_until_expiry -lt $warning_days ]]; then
            log_warn "Certificate expires in $days_until_expiry days (warning)"
        else
            log_success "Certificate expires in $days_until_expiry days"
        fi
    else
        log_error "Could not read certificate expiry date"
        failed=1
    fi

    return $failed
}

# ============================================================================
# CERTIFICATE MANAGEMENT
# ============================================================================

cert_command() {
    local cmd="$1"
    shift

    case "$cmd" in
        "check")
            local domain="${1:-${PROSODY_DOMAIN:-}}"
            if [[ -z "$domain" ]]; then
                log_error "Domain required. Usage: prosody-manager cert check <domain>"
                return 1
            fi
            check_certificates_detailed "$domain"
            ;;
        "install")
            local domain="${1:-}"
            local cert_path="${2:-}"
            if [[ -z "$domain" ]]; then
                log_error "Domain required. Usage: prosody-manager cert install <domain> [cert_path]"
                return 1
            fi
            install_certificate "$domain" "$cert_path"
            ;;
        "renew")
            local domain="${1:-${PROSODY_DOMAIN:-}}"
            if [[ -z "$domain" ]]; then
                log_error "Domain required. Usage: prosody-manager cert renew <domain>"
                return 1
            fi
            renew_certificate "$domain"
            ;;
        "monitor")
            log_info "Running enhanced certificate monitoring..."
            "$SCRIPT_DIR/scripts/certificate-monitor.sh" monitor
            ;;
        "auto-renew")
            log_info "Running automatic certificate renewal check..."
            "$SCRIPT_DIR/scripts/certificate-monitor.sh" auto-renew
            ;;
        "dashboard")
            log_info "Generating certificate health dashboard..."
            "$SCRIPT_DIR/scripts/certificate-monitor.sh" dashboard
            ;;
        "status")
            log_info "Showing certificate monitoring status..."
            if [[ -f "$PROJECT_DIR/.runtime/cert-status.json" ]]; then
                cat "$PROJECT_DIR/.runtime/cert-status.json" | jq '.' 2>/dev/null || cat "$PROJECT_DIR/.runtime/cert-status.json"
            else
                log_warn "No certificate status available. Run 'prosody-manager cert monitor' first."
            fi
            ;;
        "help"|"--help"|"-h")
            show_cert_help
            ;;
        *)
            log_error "Unknown certificate command: $cmd"
            log_info "Available commands: check, install, renew, monitor, auto-renew, dashboard, status"
            return 1
            ;;
    esac
}

check_certificates_detailed() {
    local domain="$1"
    local cert_file="/etc/prosody/certs/$domain.crt"
    local key_file="/etc/prosody/certs/$domain.key"

    log_info "Detailed certificate check for domain: $domain"

    # Check certificate file exists
    if run_in_container test -f "$cert_file"; then
        log_success "Certificate file exists: $cert_file"
    else
        log_error "Certificate file not found: $cert_file"
        return 1
    fi

    # Check key file exists
    if run_in_container test -f "$key_file"; then
        log_success "Private key file exists: $key_file"
    else
        log_error "Private key file not found: $key_file"
        return 1
    fi

    # Check certificate details
    log_info "Certificate details:"
    run_in_container openssl x509 -in "$cert_file" -noout -subject -issuer -dates -fingerprint

    # Check certificate chain
    log_info "Verifying certificate chain..."
    if run_in_container openssl verify "$cert_file" > /dev/null 2>&1; then
        log_success "Certificate chain is valid"
    else
        log_warn "Certificate chain verification failed (may be self-signed)"
    fi

    return 0
}

install_certificate() {
    local domain="$1"
    local cert_path="$2"

    if [[ -n "$cert_path" ]]; then
        log_info "Installing certificate from: $cert_path"
        # Copy certificate files to container
        docker cp "$cert_path/$domain.crt" "$(get_container_name):/etc/prosody/certs/"
        docker cp "$cert_path/$domain.key" "$(get_container_name):/etc/prosody/certs/"
    else
        log_info "Generating self-signed certificate for domain: $domain"
        run_in_container prosodyctl cert generate "$domain"
    fi

    # Set proper permissions
    run_in_container chown prosody:prosody "/etc/prosody/certs/$domain.crt" "/etc/prosody/certs/$domain.key"
    run_in_container chmod 644 "/etc/prosody/certs/$domain.crt"
    run_in_container chmod 600 "/etc/prosody/certs/$domain.key"

    # Reload Prosody to use new certificate
    run_in_container prosodyctl reload

    log_success "Certificate installed for domain: $domain"
}

renew_certificate() {
    local domain="$1"

    log_info "Renewing certificate for domain: $domain"

    # Check if using Let's Encrypt
    if run_in_container test -f "/etc/letsencrypt/live/$domain/fullchain.pem"; then
        log_info "Renewing Let's Encrypt certificate..."
        run_in_container xmpp-certbot renew --cert-name "$domain"

        # Copy renewed certificate
        run_in_container cp "/etc/letsencrypt/live/$domain/fullchain.pem" "/etc/prosody/certs/$domain.crt"
        run_in_container cp "/etc/letsencrypt/live/$domain/privkey.pem" "/etc/prosody/certs/$domain.key"

        # Set permissions
        run_in_container chown prosody:prosody "/etc/prosody/certs/$domain.crt" "/etc/prosody/certs/$domain.key"
        run_in_container chmod 644 "/etc/prosody/certs/$domain.crt"
        run_in_container chmod 600 "/etc/prosody/certs/$domain.key"

        # Reload Prosody
        run_in_container prosodyctl reload

        log_success "Let's Encrypt certificate renewed for domain: $domain"
    else
        log_warn "Let's Encrypt certificate not found. Generating new self-signed certificate..."
        install_certificate "$domain"
    fi
}

# ============================================================================
# BACKUP MANAGEMENT
# ============================================================================

backup_command() {
    local cmd="${1:-create}"
    shift || true

    case "$cmd" in
        "create")
            create_backup "$@"
            ;;
        "restore")
            restore_backup "$@"
            ;;
        "list")
            list_backups
            ;;
        *)
            error_with_guidance "Unknown backup command: $cmd" \
                "Available commands: create, restore, list" \
                "$EXIT_INVALID_ARGS"
            return "$EXIT_INVALID_ARGS"
            ;;
    esac
}

create_backup() {
    local backup_name
    backup_name="${1:-prosody_backup_$(date +%Y%m%d_%H%M%S)}"
    local backup_dir="${BACKUP_DIR:-$PROJECT_DIR/backups}"
    local backup_path="$backup_dir/$backup_name"

    log_info "Creating backup: $backup_name"

    # Create backup directory
    mkdir -p "$backup_path"

    # Backup configuration
    log_info "Backing up configuration..."
    cp -r "$CONFIG_DIR" "$backup_path/"

    # Backup Docker configuration
    log_info "Backing up Docker configuration..."
    cp -r "$DOCKER_DIR" "$backup_path/"

    # Backup Prosody data from container
    if ! is_docker_environment && docker ps --format '{{.Names}}' | grep -q "prosody"; then
        log_info "Backing up Prosody data from container..."
        mkdir -p "$backup_path/prosody-data"

        # Backup data directory
        docker cp "$(get_container_name):/var/lib/prosody/data" "$backup_path/prosody-data/"

        # Backup certificates
        docker cp "$(get_container_name):/etc/prosody/certs" "$backup_path/prosody-data/"

        # Backup database (if PostgreSQL)
        if docker ps --format '{{.Names}}' | grep -q "db"; then
            log_info "Backing up PostgreSQL database..."
            docker exec xmpp-postgres pg_dump -U prosody prosody > "$backup_path/database.sql"
        fi
    fi

    # Create archive
    log_info "Creating backup archive..."
    cd "$backup_dir"
    tar -czf "${backup_name}.tar.gz" "$backup_name"
    rm -rf "$backup_name"

    log_success "Backup created: $backup_dir/${backup_name}.tar.gz"
}

restore_backup() {
    local backup_file="$1"

    if [[ -z "$backup_file" ]]; then
        log_error "Backup file required. Usage: prosody-manager backup restore <backup_file>"
        return 1
    fi

    if [[ ! -f "$backup_file" ]]; then
        log_error "Backup file not found: $backup_file"
        return 1
    fi

    log_warn "This will restore from backup and may overwrite current data."
    read -r -p "Continue? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Restore cancelled"
        return 0
    fi

    log_info "Restoring from backup: $backup_file"

    # Extract backup
    local temp_dir
    temp_dir=$(mktemp -d)
    tar -xzf "$backup_file" -C "$temp_dir"

    local backup_name
    backup_name=$(basename "$backup_file" .tar.gz)
    local backup_path="$temp_dir/$backup_name"

    # Stop services
    if ! is_docker_environment; then
        log_info "Stopping services..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" down
    fi

    # Restore configuration
    if [[ -d "$backup_path/config" ]]; then
        log_info "Restoring configuration..."
        cp -r "$backup_path/config"/* "$CONFIG_DIR/"
    fi

    # Restore Docker configuration
    if [[ -d "$backup_path/docker" ]]; then
        log_info "Restoring Docker configuration..."
        cp -r "$backup_path/docker"/* "$DOCKER_DIR/"
    fi

    # Restore Prosody data
    if [[ -d "$backup_path/prosody-data" ]] && ! is_docker_environment; then
        log_info "Starting services to restore data..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" up -d

        # Wait for services to start
        sleep 10

        # Restore data
        if [[ -d "$backup_path/prosody-data/data" ]]; then
            docker cp "$backup_path/prosody-data/data" "$(get_container_name):/var/lib/prosody/"
        fi

        if [[ -d "$backup_path/prosody-data/certs" ]]; then
            docker cp "$backup_path/prosody-data/certs" "$(get_container_name):/etc/prosody/"
        fi

        # Restore database
        if [[ -f "$backup_path/database.sql" ]]; then
            log_info "Restoring database..."
            docker exec -i xmpp-postgres psql -U prosody prosody < "$backup_path/database.sql"
        fi
    fi

    # Cleanup
    rm -rf "$temp_dir"

    if ! is_docker_environment; then
        log_info "Restarting services..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" restart
    fi

    log_success "Backup restored successfully"
}

list_backups() {
    local backup_dir="${BACKUP_DIR:-$PROJECT_DIR/backups}"

    if [[ ! -d "$backup_dir" ]]; then
        log_info "No backup directory found: $backup_dir"
        return 0
    fi

    log_info "Available backups in $backup_dir:"

    if find "$backup_dir" -name "*.tar.gz" -type f | head -1 > /dev/null 2>&1; then
        find "$backup_dir" -name "*.tar.gz" -type f -exec ls -lah {} \; | while read -r line; do
            echo "  $line"
        done
    else
        log_info "No backups found"
    fi
}

# ============================================================================
# DEPLOYMENT MANAGEMENT
# ============================================================================

deploy_command() {
    local cmd="${1:-up}"
    shift || true

    case "$cmd" in
        "up" | "start")
            deploy_up "$@"
            ;;
        "down" | "stop")
            deploy_down "$@"
            ;;
        "restart")
            deploy_restart "$@"
            ;;
        "logs")
            deploy_logs "$@"
            ;;
        "status")
            deploy_status
            ;;
        *)
            log_error "Unknown deploy command: $cmd"
            log_info "Available commands: up, down, restart, logs, status"
            return 1
            ;;
    esac
}

deploy_up() {
    local mode="${1:-full}"

    log_info "Deploying Prosody XMPP server (mode: $mode)..."

    # Check prerequisites
    if ! command_exists docker; then
        log_error "Docker is required but not installed"
        return 1
    fi

    if ! docker compose version > /dev/null 2>&1; then
        log_error "Docker Compose is required but not installed"
        return 1
    fi

    # Check for .env file
    if [[ ! -f "$PROJECT_DIR/.env" ]]; then
        log_warn "No .env file found. Creating from example..."
        if [[ -f "$PROJECT_DIR/examples/env.example" ]]; then
            cp "$PROJECT_DIR/examples/env.example" "$PROJECT_DIR/.env"
            log_info "Please edit .env file with your configuration"
            return 1
        else
            log_error "No .env example file found"
            return 1
        fi
    fi

    # Deploy based on mode
    case "$mode" in
        "minimal")
            log_info "Starting minimal deployment (Prosody only)..."
            docker compose -f "$DOCKER_DIR/docker-compose.yml" up -d xmpp-prosody
            ;;
        "full" | *)
            log_info "Starting full deployment (all services)..."
            docker compose -f "$DOCKER_DIR/docker-compose.yml" up -d
            ;;
    esac

    # Wait for services to be ready
    log_info "Waiting for services to be ready..."
    sleep 10

    # Run health check
    if health_check > /dev/null 2>&1; then
        log_success "Deployment successful! Services are healthy."
    else
        log_warn "Deployment completed but some health checks failed."
        log_info "Run 'prosody-manager health' for detailed status."
    fi
}

deploy_down() {
    log_info "Stopping Prosody XMPP server..."
    docker compose -f "$DOCKER_DIR/docker-compose.yml" down "$@"
    log_success "Services stopped"
}

deploy_restart() {
    local service="${1:-}"

    if [[ -n "$service" ]]; then
        log_info "Restarting service: $service"
        docker compose -f "$DOCKER_DIR/docker-compose.yml" restart "$service"
    else
        log_info "Restarting all services..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" restart
    fi

    log_success "Services restarted"
}

deploy_logs() {
    local service="${1:-}"
    local args=("${@:2}")

    if [[ -n "$service" ]]; then
        docker compose -f "$DOCKER_DIR/docker-compose.yml" logs "${args[@]}" "$service"
    else
        docker compose -f "$DOCKER_DIR/docker-compose.yml" logs "${args[@]}"
    fi
}

deploy_status() {
    log_info "Service status:"
    docker compose -f "$DOCKER_DIR/docker-compose.yml" ps

    echo
    log_info "Resource usage:"
    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"
}

# ============================================================================
# MODULE MANAGEMENT FUNCTIONS
# ============================================================================

readonly MODULES_DIR="/usr/local/lib/prosody/community-modules"
readonly MODULES_REPO="https://hg.prosody.im/prosody-modules/"
readonly TEMP_MODULES_DIR="$PROJECT_DIR/.prosody-modules"
# Change: export ROCKS_SERVER if used externally, otherwise remove if unused
export ROCKS_SERVER="https://modules.prosody.im/rocks/"

module_command() {
    local subcommand="${1:-help}"
    shift || true

    case "$subcommand" in
        "list")
            module_list "$@"
            ;;
        "search")
            module_search "$@"
            ;;
        "install")
            module_install "$@"
            ;;
        "remove")
            module_remove "$@"
            ;;
        "update")
            module_update "$@"
            ;;
        "info")
            module_info "$@"
            ;;
        "sync")
            module_sync "$@"
            ;;
        "rocks")
            module_rocks "$@"
            ;;
        "help" | "-h" | "--help")
            module_help
            ;;
        *)
            log_error "Unknown module subcommand: $subcommand"
            echo
            module_help
            exit 1
            ;;
    esac
}

module_list() {
    local filter="${1:-}"
    # local show_rocks="${2:-false}"  # Removed as unused

    log_info "Installed modules:"

    # List manually installed modules (from community repo)
    if [[ -d "$MODULES_DIR" ]]; then
        local count=0
        echo -e "${BOLD}Community Modules (from prosody-modules):${NC}"
        for module_dir in "$MODULES_DIR"/mod_*; do
            if [[ -d "$module_dir" ]]; then
                local module_name
                module_name=$(basename "$module_dir")
                if [[ -z "$filter" || "$module_name" == *"$filter"* ]]; then
                    echo -e "  ${GREEN}✓${NC} $module_name ${CYAN}(community)${NC}"
                    ((count++))
                fi
            fi
        done

        if [[ $count -eq 0 ]]; then
            echo -e "  ${YELLOW}No community modules installed${NC}"
        fi
        echo
    fi

    # List LuaRocks installed modules (via prosodyctl install)
    echo -e "${BOLD}Official Modules (via LuaRocks):${NC}"
    if command_exists prosodyctl; then
        if run_in_container prosodyctl list 2> /dev/null | grep -q "mod_"; then
            run_in_container prosodyctl list 2> /dev/null | grep "mod_" | while read -r line; do
                if [[ -z "$filter" || "$line" == *"$filter"* ]]; then
                    echo -e "  ${GREEN}✓${NC} $line ${BLUE}(official)${NC}"
                fi
            done
        else
            echo -e "  ${YELLOW}No official modules installed via LuaRocks${NC}"
        fi
    else
        echo -e "  ${YELLOW}prosodyctl not available${NC}"
    fi
}

module_search() {
    local query="${1:-}"

    if [[ -z "$query" ]]; then
        log_error "Please provide a search term"
        echo "Usage: prosody-manager module search <query>"
        return 1
    fi

    log_info "Searching for modules matching: $query"
    echo

    # Search official LuaRocks repository
    echo -e "${BOLD}Official Repository (LuaRocks):${NC}"
    if command_exists luarocks; then
        if run_in_container luarocks search --porcelain "$query" 2> /dev/null | grep -q "mod_"; then
            run_in_container luarocks search --porcelain "$query" 2> /dev/null | grep "mod_" | while read -r name version; do
                echo -e "  ${BLUE}$name${NC} ${CYAN}($version)${NC} - Install with: ${GREEN}prosody-manager module rocks install $name${NC}"
            done
        else
            echo -e "  ${YELLOW}No official modules found${NC}"
        fi
    else
        echo -e "  ${YELLOW}LuaRocks not available${NC}"
    fi

    echo

    # Search community repository
    echo -e "${BOLD}Community Repository (prosody-modules):${NC}"

    # Clone or update the modules repository
    if [[ ! -d "$TEMP_MODULES_DIR" ]]; then
        log_info "Downloading modules repository..."
        hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" > /dev/null 2>&1
    else
        log_info "Updating modules repository..."
        (cd "$TEMP_MODULES_DIR" && hg pull -u > /dev/null 2>&1)
    fi

    local count=0
    for module_dir in "$TEMP_MODULES_DIR"/mod_*; do
        if [[ -d "$module_dir" ]]; then
            local module_name
            module_name=$(basename "$module_dir")
            if [[ "$module_name" == *"$query"* ]]; then
                local installed=""
                if [[ -d "$MODULES_DIR/$module_name" ]]; then
                    installed=" ${GREEN}(installed)${NC}"
                fi
                echo -e "  ${CYAN}$module_name${NC}$installed - Install with: ${GREEN}prosody-manager module install $module_name${NC}"

                # Show description if available
                local readme="$module_dir/README.markdown"
                if [[ -f "$readme" ]]; then
                    local desc
                    desc=$(head -n 5 "$readme" | grep -E "^[A-Z].*" | head -n 1 | cut -c1-80)
                    if [[ -n "$desc" ]]; then
                        echo -e "    ${desc}..."
                    fi
                fi
                ((count++))
            fi
        fi
    done

    if [[ $count -eq 0 ]]; then
        echo -e "  ${YELLOW}No community modules found${NC}"
    fi

    echo
    log_info "💡 Tip: Use 'prosody-manager module rocks install <name>' for official modules with dependency handling"
    log_info "💡 Tip: Use 'prosody-manager module install <name>' for community modules (manual dependency management)"
}

module_install() {
    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        error_with_guidance "Missing required argument: module name" \
            "Usage: prosody-manager module install <module_name>" \
            "$EXIT_INVALID_ARGS"
        echo "  For official modules with dependencies: prosody-manager module rocks install <module_name>"
        return "$EXIT_INVALID_ARGS"
    fi

    # Add mod_ prefix if not present
    if [[ "$module_name" != mod_* ]]; then
        module_name="mod_$module_name"
    fi

    # Validate module name
    if ! validate_module_name "$module_name"; then
        error_with_guidance "Invalid module name format: $module_name" \
            "Module name should contain only alphanumeric characters and underscores" \
            "$EXIT_INVALID_ARGS"
        return "$EXIT_INVALID_ARGS"
    fi

    log_info "Installing community module: $module_name"

    # Check if already installed
    if [[ -d "$MODULES_DIR/$module_name" ]]; then
        log_warn "Module $module_name is already installed"
        read -r -p "Overwrite? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Installation cancelled"
            return 0
        fi
    fi

    # Check for required tools
    if ! command_exists hg; then
        error_with_guidance "Mercurial (hg) is required but not installed" \
            "Install Mercurial: sudo apt-get install mercurial (Ubuntu/Debian) or brew install mercurial (macOS)" \
            "$EXIT_MISSING_DEPENDENCY"
        return "$EXIT_MISSING_DEPENDENCY"
    fi

    # Clone or update the modules repository
    if [[ ! -d "$TEMP_MODULES_DIR" ]]; then
        log_info "Downloading modules repository..."
        if ! hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" > /dev/null 2>&1; then
            error_with_guidance "Failed to download modules repository" \
                "Check internet connection and try again" \
                "$EXIT_NETWORK_ERROR"
            return "$EXIT_NETWORK_ERROR"
        fi
    fi

    local source_dir="$TEMP_MODULES_DIR/$module_name"
    if [[ ! -d "$source_dir" ]]; then
        error_with_guidance "Module not found: $module_name" \
            "Use 'prosody-manager module search <term>' to find available modules" \
            "$EXIT_GENERAL_ERROR"
        return "$EXIT_GENERAL_ERROR"
    fi

    # Create modules directory if it doesn't exist
    if ! run_in_container mkdir -p "$MODULES_DIR"; then
        error_with_guidance "Failed to create modules directory" \
            "Check container permissions and disk space" \
            "$EXIT_PERMISSION_ERROR"
        return "$EXIT_PERMISSION_ERROR"
    fi

    # Copy module files
    if is_docker_environment; then
        if ! cp -r "$source_dir" "$MODULES_DIR/"; then
            error_with_guidance "Failed to copy module files" \
                "Check disk space and permissions" \
                "$EXIT_PERMISSION_ERROR"
            return "$EXIT_PERMISSION_ERROR"
        fi
        chown -R prosody:prosody "$MODULES_DIR/$module_name" 2> /dev/null || true
    else
        if ! docker cp "$source_dir" "$(get_container_name):$MODULES_DIR/"; then
            error_with_guidance "Failed to copy module to container" \
                "Check if container is running and has sufficient disk space" \
                "$EXIT_GENERAL_ERROR"
            return "$EXIT_GENERAL_ERROR"
        fi
        if ! run_in_container chown -R prosody:prosody "$MODULES_DIR/$module_name"; then
            log_warn "Failed to set module ownership (may affect functionality)"
        fi
    fi

    log_success "Community module $module_name installed successfully"
    log_warn "⚠️  This is a community module - check dependencies manually!"
    log_info "📖 Read the module documentation for setup instructions"
    log_info "🔧 Add '$module_name' to your modules_enabled list and reload Prosody"
}

module_rocks() {
    local subcmd="${1:-help}"
    shift || true

    case "$subcmd" in
        "install")
            local module_name="${1:-}"
            if [[ -z "$module_name" ]]; then
                log_error "Please provide a module name"
                echo "Usage: prosody-manager module rocks install <module_name>"
                return 1
            fi

            log_info "Installing official module via LuaRocks: $module_name"
            if run_in_container prosodyctl install "$module_name"; then
                log_success "Official module $module_name installed successfully"
                log_info "✅ Dependencies handled automatically by LuaRocks"
                log_info "🔧 Add '$module_name' to your modules_enabled list and reload Prosody"
            else
                log_error "Failed to install $module_name via prosodyctl"
                log_info "💡 Try: prosody-manager module install $module_name (for community modules)"
            fi
            ;;
        "list")
            run_in_container prosodyctl list "$@"
            ;;
        "remove")
            local module_name="${1:-}"
            if [[ -z "$module_name" ]]; then
                log_error "Please provide a module name"
                echo "Usage: prosody-manager module rocks remove <module_name>"
                return 1
            fi

            log_info "Removing official module: $module_name"
            run_in_container prosodyctl remove "$module_name"
            ;;
        "outdated")
            run_in_container prosodyctl list --outdated
            ;;
        "help")
            echo -e "${BOLD}Official Module Management (LuaRocks)${NC}"
            echo
            echo -e "${GREEN}install <module>${NC}    Install official module with dependencies"
            echo -e "${GREEN}remove <module>${NC}     Remove official module"
            echo -e "${GREEN}list${NC}               List installed official modules"
            echo -e "${GREEN}outdated${NC}           List outdated official modules"
            ;;
        *)
            log_error "Unknown rocks subcommand: $subcmd"
            module_rocks help
            return 1
            ;;
    esac
}

module_remove() {
    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        log_error "Please provide a module name"
        echo "Usage: prosody-manager module remove <module_name>"
        echo "  For official modules: prosody-manager module rocks remove <module_name>"
        return 1
    fi

    # Add mod_ prefix if not present
    if [[ "$module_name" != mod_* ]]; then
        module_name="mod_$module_name"
    fi

    local module_path="$MODULES_DIR/$module_name"

    # Check if it's a community module
    if run_in_container test -d "$module_path"; then
        log_warn "This will remove community module: $module_name"
        read -r -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Removal cancelled"
            return 0
        fi

        run_in_container rm -rf "$module_path"
        log_success "Community module $module_name removed successfully"
    else
        log_error "Community module not found: $module_name"
        log_info "💡 For official modules, use: prosody-manager module rocks remove $module_name"
        return 1
    fi

    log_info "🔧 Remove '$module_name' from your modules_enabled list and reload Prosody"
}

module_update() {
    local module_name="${1:-}"

    if [[ -n "$module_name" ]]; then
        # Update specific community module
        if [[ "$module_name" != mod_* ]]; then
            module_name="mod_$module_name"
        fi

        if [[ ! -d "$MODULES_DIR/$module_name" ]]; then
            log_error "Community module not installed: $module_name"
            return 1
        fi

        log_info "Updating community module: $module_name"
        module_install "$module_name"
    else
        # Update all modules
        log_info "Updating all modules..."

        # Update community modules
        if [[ -d "$MODULES_DIR" ]]; then
            local count=0
            echo -e "${BOLD}Updating community modules:${NC}"
            for module_dir in "$MODULES_DIR"/mod_*; do
                if [[ -d "$module_dir" ]]; then
                    local module_name
                    module_name=$(basename "$module_dir")
                    log_info "Updating $module_name..."
                    module_install "$module_name"
                    ((count++))
                fi
            done
            echo -e "${GREEN}Updated $count community module(s)${NC}"
        fi

        # Update official modules
        echo -e "${BOLD}Updating official modules:${NC}"
        if run_in_container prosodyctl list --outdated 2> /dev/null | grep -q "mod_"; then
            run_in_container prosodyctl list --outdated 2> /dev/null | grep "mod_" | while read -r module_info; do
                local module_name
                module_name=$(echo "$module_info" | awk '{print $1}')
                log_info "Updating official module: $module_name"
                run_in_container prosodyctl install "$module_name"
            done
        else
            log_info "All official modules are up to date"
        fi
    fi
}

module_info() {
    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        log_error "Please provide a module name"
        echo "Usage: prosody-manager module info <module_name>"
        return 1
    fi

    # Add mod_ prefix if not present
    if [[ "$module_name" != mod_* ]]; then
        module_name="mod_$module_name"
    fi

    log_info "Module information: $module_name"

    # Check if installed as community module
    local installed_path="$MODULES_DIR/$module_name"
    if run_in_container test -d "$installed_path"; then
        echo -e "  ${GREEN}Status:${NC} Installed (Community)"
        echo -e "  ${GREEN}Path:${NC} $installed_path"

        # Show files
        echo -e "  ${GREEN}Files:${NC}"
        run_in_container find "$installed_path" -type f -name "*.lua" | head -10 | while read -r file; do
            echo "    $(basename "$file")"
        done
    else
        echo -e "  ${YELLOW}Community Status:${NC} Not installed"
    fi

    # Check if installed as official module
    if run_in_container prosodyctl list 2> /dev/null | grep -q "$module_name"; then
        echo -e "  ${BLUE}Official Status:${NC} Installed via LuaRocks"
    else
        echo -e "  ${YELLOW}Official Status:${NC} Not installed"
    fi

    # Get info from community repository
    if [[ ! -d "$TEMP_MODULES_DIR" ]]; then
        hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" > /dev/null 2>&1
    fi

    local repo_path="$TEMP_MODULES_DIR/$module_name"
    if [[ -d "$repo_path" ]]; then
        echo -e "  ${GREEN}Community Available:${NC} Yes"

        # Show README if available
        local readme="$repo_path/README.markdown"
        if [[ -f "$readme" ]]; then
            echo -e "  ${GREEN}Description:${NC}"
            head -n 10 "$readme" | sed 's/^/    /'
        fi
    else
        echo -e "  ${YELLOW}Community Available:${NC} No"
    fi

    # Check if available in official repository
    if run_in_container luarocks search --porcelain "$module_name" 2> /dev/null | grep -q "$module_name"; then
        echo -e "  ${BLUE}Official Available:${NC} Yes (via LuaRocks)"
        echo -e "  ${BLUE}Install Command:${NC} prosody-manager module rocks install $module_name"
    else
        echo -e "  ${YELLOW}Official Available:${NC} No"
    fi
}

module_sync() {
    log_info "Synchronizing community modules repository..."

    if [[ -d "$TEMP_MODULES_DIR" ]]; then
        rm -rf "$TEMP_MODULES_DIR"
    fi

    hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" > /dev/null 2>&1
    log_success "Community modules repository synchronized"

    # Also update LuaRocks cache
    log_info "Updating LuaRocks cache..."
    run_in_container luarocks list --outdated > /dev/null 2>&1 || true
    log_success "LuaRocks cache updated"
}

module_help() {
    echo -e "${BOLD}Module Management Commands${NC}"
    echo
    echo -e "${BOLD}OVERVIEW:${NC}"
    echo "  Two types of modules are supported:"
    echo -e "  ${BLUE}• Official modules${NC} - Installed via LuaRocks with automatic dependency handling"
    echo -e "  ${CYAN}• Community modules${NC} - Installed from prosody-modules repository (manual dependencies)"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager module <subcommand> [options]"
    echo
    echo -e "${BOLD}GENERAL COMMANDS:${NC}"
    echo -e "    ${GREEN}list [filter]${NC}           List all installed modules"
    echo -e "    ${GREEN}search <query>${NC}          Search both official and community modules"
    echo -e "    ${GREEN}info <module>${NC}           Show detailed module information"
    echo -e "    ${GREEN}update [module]${NC}         Update module(s)"
    echo -e "    ${GREEN}sync${NC}                    Sync module repositories"
    echo
    echo -e "${BOLD}COMMUNITY MODULES (prosody-modules):${NC}"
    echo -e "    ${GREEN}install <module>${NC}        Install community module (manual dependencies)"
    echo -e "    ${GREEN}remove <module>${NC}         Remove community module"
    echo
    echo -e "${BOLD}OFFICIAL MODULES (LuaRocks):${NC}"
    echo -e "    ${GREEN}rocks install <module>${NC}  Install official module with dependencies"
    echo -e "    ${GREEN}rocks remove <module>${NC}   Remove official module"
    echo -e "    ${GREEN}rocks list${NC}              List official modules only"
    echo -e "    ${GREEN}rocks outdated${NC}          List outdated official modules"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    # Search for modules"
    echo "    prosody-manager module search cloud"
    echo
    echo "    # Install official module (recommended for production)"
    echo "    prosody-manager module rocks install mod_cloud_notify"
    echo
    echo "    # Install community module (bleeding edge)"
    echo "    prosody-manager module install mod_pastebin"
    echo
    echo "    # List all modules"
    echo "    prosody-manager module list"
    echo
    echo "    # Update all modules"
    echo "    prosody-manager module update"
    echo
    echo -e "${BOLD}RECOMMENDATIONS:${NC}"
    echo -e "  ${BLUE}• Production:${NC} Use 'rocks install' for official modules with dependency handling"
    echo -e "  ${CYAN}• Development:${NC} Use 'install' for latest community modules"
    echo -e "  ${YELLOW}• Always:${NC} Read module documentation before enabling"
}

# ============================================================================
# DEVELOPMENT TOOLS FUNCTIONS
# ============================================================================

dev_command() {
    local cmd="${1:-help}"
    shift || true

    # Development environment configuration
    local DEV_COMPOSE_FILE="$PROJECT_DIR/docker-compose.dev.yml"

    # Check if development environment is available
    check_dev_environment() {
        if [[ ! -f "$DEV_COMPOSE_FILE" ]]; then
            log_error "Development compose file not found: $DEV_COMPOSE_FILE"
            return 1
        fi

        if ! docker compose -f "$DEV_COMPOSE_FILE" ps | grep -q "xmpp-prosody-dev"; then
            log_error "Development environment is not running!"
            log_info "Start it with: prosody-manager setup --dev"
            return 1
        fi
        return 0
    }

    case "$cmd" in
        "status")
            log_info "Development Environment Status"
            echo

            # Check services
            echo -e "${BLUE}Services Status:${NC}"
            docker compose -f "$DEV_COMPOSE_FILE" ps
            echo

            # Check health
            echo -e "${BLUE}Health Checks:${NC}"
            docker compose -f "$DEV_COMPOSE_FILE" ps --format "table {{.Name}}\t{{.Status}}\t{{.Health}}"
            echo

            # Check logs for errors
            echo -e "${BLUE}Recent Errors (last 50 lines):${NC}"
            if docker compose -f "$DEV_COMPOSE_FILE" logs --tail=50 | grep -i error || true; then
                echo "No recent errors found ✓"
            fi
            ;;
        "urls")
            log_info "Development Environment URLs"
            echo
            echo -e "${BLUE}Access URLs:${NC}"
            echo "  🌐 Development Tools:    http://localhost:8081"
            echo "  🔧 Admin Panel (HTTP):   http://localhost:5280/admin"
            echo "  🔒 Admin Panel (HTTPS):  https://localhost:5281/admin"
            echo "  🗄️  Database Admin:       http://localhost:8080"
            echo "  📊 Log Viewer:          http://localhost:8082"
            echo "  📈 Metrics:             http://localhost:5280/metrics"
            echo "  📁 Static Files:        http://localhost:5280/files/"
            echo "  📤 File Upload:         https://localhost:5281/upload"
            echo
            echo -e "${BLUE}XMPP Endpoints:${NC}"
            echo "  📱 C2S (STARTTLS):      localhost:5222"
            echo "  🔒 C2S (Direct TLS):    localhost:5223"
            echo "  🌐 WebSocket:           ws://localhost:5280/xmpp-websocket"
            echo "  🌐 WebSocket (TLS):     wss://localhost:5281/xmpp-websocket"
            echo "  🌐 BOSH:               http://localhost:5280/http-bind"
            echo "  🌐 BOSH (TLS):         https://localhost:5281/http-bind"
            echo
            ;;
        "test")
            log_info "Testing XMPP Connectivity"

            if ! check_dev_environment; then
                return 1
            fi

            echo
            echo -e "${BLUE}Testing XMPP Ports:${NC}"

            # Test C2S port
            if timeout 3 bash -c "</dev/tcp/localhost/5222" 2> /dev/null; then
                echo "  ✅ C2S (5222): Reachable"
            else
                echo "  ❌ C2S (5222): Not reachable"
            fi

            # Test C2S Direct TLS port
            if timeout 3 bash -c "</dev/tcp/localhost/5223" 2> /dev/null; then
                echo "  ✅ C2S Direct TLS (5223): Reachable"
            else
                echo "  ❌ C2S Direct TLS (5223): Not reachable"
            fi

            # Test HTTP port
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:5280/admin | grep -q "200\|401"; then
                echo "  ✅ HTTP (5280): Reachable"
            else
                echo "  ❌ HTTP (5280): Not reachable"
            fi

            # Test HTTPS port (ignore cert errors for dev)
            if curl -k -s -o /dev/null -w "%{http_code}" https://localhost:5281/admin | grep -q "200\|401"; then
                echo "  ✅ HTTPS (5281): Reachable"
            else
                echo "  ❌ HTTPS (5281): Not reachable"
            fi

            echo
            echo -e "${BLUE}Testing Development Tools:${NC}"

            # Test Adminer
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 | grep -q "200"; then
                echo "  ✅ Database Admin (8080): Available"
            else
                echo "  ❌ Database Admin (8080): Not available"
            fi

            # Test Web Client
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:8081 | grep -q "200"; then
                echo "  ✅ Web Client (8081): Available"
            else
                echo "  ❌ Web Client (8081): Not available"
            fi

            # Test Log Viewer
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:8082 | grep -q "200"; then
                echo "  ✅ Log Viewer (8082): Available"
            else
                echo "  ❌ Log Viewer (8082): Not available"
            fi

            echo
            ;;
        "config")
            log_info "Testing Prosody Configuration"

            if ! check_dev_environment; then
                return 1
            fi

            echo
            echo -e "${BLUE}Configuration Check:${NC}"
            docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl check config

            echo
            echo -e "${BLUE}Connectivity Check:${NC}"
            docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl check connectivity localhost

            echo
            echo -e "${BLUE}Module Check:${NC}"
            docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl check modules
            ;;
        "users")
            log_info "Listing XMPP Users"

            if ! check_dev_environment; then
                return 1
            fi

            echo
            echo -e "${BLUE}Users on localhost domain:${NC}"
            docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl list users localhost || echo "No users found"
            echo
            ;;
        "adduser")
            local username="$1"
            local password="${2:-}"

            if [[ -z "$username" ]]; then
                log_error "Username required"
                echo "Usage: prosody-manager dev adduser <username> [password]"
                return 1
            fi

            log_info "Creating XMPP User: $username@localhost"

            if ! check_dev_environment; then
                return 1
            fi

            if [[ -z "$password" ]]; then
                docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl adduser "$username@localhost"
            else
                echo "$password" | docker compose -f "$DEV_COMPOSE_FILE" exec -T xmpp-prosody-dev prosodyctl adduser "$username@localhost"
            fi

            log_success "User $username@localhost created successfully ✓"
            ;;
        "deluser")
            local username="$1"

            if [[ -z "$username" ]]; then
                log_error "Username required"
                echo "Usage: prosody-manager dev deluser <username>"
                return 1
            fi

            log_info "Deleting XMPP User: $username@localhost"

            if ! check_dev_environment; then
                return 1
            fi

            docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl deluser "$username@localhost"

            log_success "User $username@localhost deleted successfully ✓"
            ;;
        "passwd")
            local username="$1"

            if [[ -z "$username" ]]; then
                log_error "Username required"
                echo "Usage: prosody-manager dev passwd <username>"
                return 1
            fi

            log_info "Changing Password for: $username@localhost"

            if ! check_dev_environment; then
                return 1
            fi

            docker compose -f "$DEV_COMPOSE_FILE" exec xmpp-prosody-dev prosodyctl passwd "$username@localhost"

            log_success "Password changed for $username@localhost ✓"
            ;;
        "logs")
            local service="${1:-}"
            local lines="${2:-50}"

            log_info "Showing Development Environment Logs"

            if ! check_dev_environment; then
                return 1
            fi

            if [[ -n "$service" ]]; then
                echo -e "${BLUE}Logs for $service (last $lines lines):${NC}"
                docker compose -f "$DEV_COMPOSE_FILE" logs --tail="$lines" -f "$service"
            else
                echo -e "${BLUE}All logs (last $lines lines):${NC}"
                docker compose -f "$DEV_COMPOSE_FILE" logs --tail="$lines" -f
            fi
            ;;
        "restart")
            local service="${1:-xmpp-prosody-dev}"

            log_info "Restarting Service: $service"

            if ! check_dev_environment; then
                return 1
            fi

            docker compose -f "$DEV_COMPOSE_FILE" restart "$service"

            log_success "Service $service restarted ✓"
            ;;
        "cleanup")
            log_info "Cleaning Up Development Environment"

            echo -e "${YELLOW}This will stop all development containers and optionally remove data${NC}"
            if ! confirm "Continue?" "N"; then
                log_info "Cleanup cancelled"
                return 0
            fi

            # Stop containers
            docker compose -f "$DEV_COMPOSE_FILE" down

            # Ask about volumes
            if confirm "Remove development data volumes?" "N"; then
                docker volume rm -f xmpp_prosody_data_dev xmpp_prosody_uploads_dev xmpp_postgres_data_dev xmpp_coturn_data_dev xmpp_certs_dev 2> /dev/null || true
                log_success "Development volumes removed ✓"
            fi

            log_success "Development environment cleaned up ✓"
            ;;
        "backup")
            local backup_dir
            backup_dir="$PROJECT_DIR/backups/dev-$(date +%Y%m%d-%H%M%S)"

            log_info "Backing Up Development Data"

            if ! check_dev_environment; then
                return 1
            fi

            mkdir -p "$backup_dir"

            # Backup database
            log_info "Backing up PostgreSQL database..."
            docker compose -f "$DEV_COMPOSE_FILE" exec -T xmpp-postgres-dev pg_dump -U prosody prosody > "$backup_dir/database.sql"

            # Backup Prosody data
            log_info "Backing up Prosody data..."
            docker cp "$(docker compose -f "$DEV_COMPOSE_FILE" ps -q xmpp-prosody-dev):/var/lib/prosody/data" "$backup_dir/prosody-data"

            # Backup uploads
            log_info "Backing up file uploads..."
            docker cp "$(docker compose -f "$DEV_COMPOSE_FILE" ps -q xmpp-prosody-dev):/var/lib/prosody/uploads" "$backup_dir/uploads"

            log_success "Development data backed up to: $backup_dir ✓"
            ;;
        "perf")
            log_info "Running Performance Test"

            if ! check_dev_environment; then
                return 1
            fi

            echo -e "${BLUE}Testing connection performance...${NC}"

            # Simple connection test
            for i in {1..10}; do
                local start_time
                start_time=$(date +%s%N)
                timeout 5 bash -c "</dev/tcp/localhost/5222" 2> /dev/null
                local end_time
                end_time=$(date +%s%N)
                duration=$(((end_time - start_time) / 1000000))
                echo "  Connection $i: ${duration}ms"
            done

            echo
            echo -e "${BLUE}Memory usage:${NC}"
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}" "$(docker compose -f "$DEV_COMPOSE_FILE" ps -q)"
            ;;
        "help" | *)
            echo -e "${BOLD}Development Tools Commands${NC}"
            echo
            echo -e "${BOLD}OVERVIEW:${NC}"
            echo "  Development-specific commands for testing and managing the development environment"
            echo
            echo -e "${BOLD}USAGE:${NC}"
            echo "    prosody-manager dev <command> [arguments]"
            echo
            echo -e "${BOLD}COMMANDS:${NC}"
            echo -e "    ${GREEN}status${NC}              Show development environment status"
            echo -e "    ${GREEN}urls${NC}                Show all access URLs"
            echo -e "    ${GREEN}test${NC}                Test connectivity to all services"
            echo -e "    ${GREEN}config${NC}              Test Prosody configuration"
            echo -e "    ${GREEN}users${NC}               List all XMPP users"
            echo -e "    ${GREEN}adduser${NC} <username> [password]   Create new XMPP user"
            echo -e "    ${GREEN}deluser${NC} <username>  Delete XMPP user"
            echo -e "    ${GREEN}passwd${NC} <username>   Change user password"
            echo -e "    ${GREEN}logs${NC} [service] [lines]  Show logs (default: all services, 50 lines)"
            echo -e "    ${GREEN}restart${NC} [service]   Restart service (default: prosody)"
            echo -e "    ${GREEN}cleanup${NC}             Clean up development environment"
            echo -e "    ${GREEN}backup${NC}              Backup development data"
            echo -e "    ${GREEN}perf${NC}                Run performance test"
            echo -e "    ${GREEN}help${NC}                Show this help message"
            echo
            echo -e "${BOLD}EXAMPLES:${NC}"
            echo "    prosody-manager dev status                    # Show environment status"
            echo "    prosody-manager dev adduser alice alice123    # Create user alice with password alice123"
            echo "    prosody-manager dev logs xmpp-prosody-dev     # Show Prosody logs"
            echo "    prosody-manager dev restart                   # Restart Prosody service"
            echo "    prosody-manager dev test                      # Test all connectivity"
            echo
            echo -e "${BOLD}PREREQUISITES:${NC}"
            echo "  • Development environment must be running"
            echo "  • Start with: prosody-manager setup --dev"
            echo
            ;;
    esac
}

# ============================================================================
# MAIN COMMAND DISPATCHER
# ============================================================================

show_help() {
    local context="${1:-general}"

    case "$context" in
        "dev" | "development")
            show_development_help
            ;;
        "prod" | "production")
            show_production_help
            ;;
        *)
            show_general_help
            ;;
    esac
}

show_general_help() {
    echo -e "${BOLD}Prosody Manager v${VERSION}${NC}"
    echo "Unified CLI tool for Prosody XMPP Server management"
    echo
    echo -e "${BOLD}🚀 QUICK START:${NC}"
    echo -e "  ${CYAN}New to Prosody?${NC} Run: ${GREEN}prosody-manager setup${NC}"
    echo -e "  ${CYAN}Interactive mode:${NC} Run commands without arguments for guided setup"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager <command> [subcommand] [options]"
    echo "    prosody-manager <command>                    # Interactive mode"
    echo
    echo -e "${BOLD}CORE COMMANDS:${NC}"
    echo -e "    ${GREEN}setup${NC}           🛠️  Interactive setup wizard for new installations"
    echo -e "    ${GREEN}deploy${NC}          🚀 Deployment management (interactive if no args)"
    echo "        up [minimal|full]                   Start services"
    echo "        down                                Stop services"
    echo "        restart [service]                   Restart services"
    echo "        logs [service] [--follow]           View logs"
    echo "        status                              Show service status"
    echo
    echo -e "    ${GREEN}prosodyctl${NC}      👤 User and server management (interactive if no args)"
    echo "        adduser <user@domain> [password]    Add user account"
    echo "        deluser <user@domain>               Delete user account"
    echo "        passwd <user@domain> [password]     Change user password"
    echo "        status                              Show Prosody status"
    echo "        reload                              Reload configuration"
    echo "        restart                             Restart Prosody service"
    echo "        cert <list|import|generate>         Certificate management"
    echo
    echo -e "    ${GREEN}health${NC}          🏥 System health monitoring"
    echo "        [process|ports|config|certs|all]    Run health checks"
    echo
    echo -e "    ${GREEN}cert${NC}            🔒 Certificate management (interactive if no args)"
    echo "        check <domain>                      Check certificate status"
    echo "        install <domain> [cert_path]        Install certificate"
    echo "        renew <domain>                      Renew certificate"
    echo "        monitor                             Run certificate monitoring"
    echo "        auto-renew                          Auto-renew certificates if needed"
    echo "        dashboard                           Generate certificate health dashboard"
    echo "        status                              Show certificate monitoring status"
    echo "        renew <domain>                      Renew certificate"
    echo
    echo -e "    ${GREEN}backup${NC}          💾 Backup management (interactive if no args)"
    echo "        create [name]                       Create backup"
    echo "        restore <backup_file>               Restore from backup"
    echo "        list                                List available backups"
    echo
    echo -e "    ${GREEN}module${NC}          🧩 Module management (interactive if no args)"
    echo "        list [filter]                       List installed modules"
    echo "        search <query>                      Search available modules"
    echo "        install <module>                    Install community module"
    echo "        rocks install <module>              Install official module"
    echo "        remove <module>                     Remove a module"
    echo "        update [module]                     Update module(s)"
    echo "        info <module>                       Show module information"
    echo "        sync                                Sync modules repository"
    echo
    echo -e "    ${GREEN}dev${NC}             🛠️  Development tools (interactive if no args)"
    echo "        status                              Show development environment status"
    echo "        urls                                Show access URLs"
    echo "        test                                Test connectivity"
    echo "        config                              Test configuration"
    echo "        users                               List development users"
    echo "        adduser <username> [password]       Add development user"
    echo "        logs [service] [lines]              Show logs"
    echo "        restart [service]                   Restart service"
    echo "        backup                              Backup development data"
    echo "        cleanup                             Clean up environment"
    echo
    echo -e "${BOLD}UTILITY COMMANDS:${NC}"
    echo -e "    ${GREEN}help [dev|prod]${NC} Show this help (with environment-specific tips)"
    echo -e "    ${GREEN}version${NC}         Show version information"
    echo
    echo -e "${BOLD}💡 EXAMPLES:${NC}"
    echo -e "  ${CYAN}# First-time setup${NC}"
    echo "    prosody-manager setup"
    echo
    echo -e "  ${CYAN}# Quick deployment${NC}"
    echo "    prosody-manager deploy up"
    echo
    echo -e "  ${CYAN}# User management${NC}"
    echo "    prosody-manager prosodyctl adduser alice@chat.example.com"
    echo "    prosody-manager prosodyctl                    # Interactive mode"
    echo
    echo -e "  ${CYAN}# Health monitoring${NC}"
    echo "    prosody-manager health all"
    echo "    prosody-manager health certs"
    echo
    echo -e "  ${CYAN}# Certificate management${NC}"
    echo "    prosody-manager cert check chat.example.com"
    echo "    prosody-manager cert                          # Interactive mode"
    echo
    echo -e "  ${CYAN}# Module management${NC}"
    echo "    prosody-manager module search cloud"
    echo "    prosody-manager module rocks install mod_cloud_notify"
    echo "    prosody-manager module                        # Interactive mode"
    echo
    echo -e "  ${CYAN}# Backup operations${NC}"
    echo "    prosody-manager backup create my_backup"
    echo "    prosody-manager backup                        # Interactive mode"
    echo
    echo -e "  ${CYAN}# View logs${NC}"
    echo "    prosody-manager deploy logs prosody --follow"
    echo "    prosody-manager deploy logs"
    echo
    echo -e "${BOLD}🔧 ENVIRONMENT VARIABLES:${NC}"
    echo "    DEBUG=true                              Enable debug output"
    echo "    PROSODY_DOMAIN                          Default domain for operations"
    echo "    BACKUP_DIR                              Custom backup directory"
    echo
    echo -e "${BOLD}📚 GETTING HELP:${NC}"
    echo -e "  ${CYAN}Environment-specific help:${NC}"
    echo "    prosody-manager help dev                Development tips"
    echo "    prosody-manager help prod               Production best practices"
    echo
    echo -e "  ${CYAN}Command-specific help:${NC}"
    echo "    prosody-manager module help             Module management guide"
    echo "    prosody-manager deploy --help           Deployment options"
    echo
    echo -e "  ${CYAN}Interactive mode:${NC} Run any command without arguments for guided setup"
    echo
    echo "📖 Documentation: https://github.com/allthingslinux/xmpp.atl.chat"
    echo "🐛 Issues: https://github.com/allthingslinux/xmpp.atl.chat/issues"
}

show_development_help() {
    echo -e "${BOLD}🛠️  Development Environment Help${NC}"
    echo
    echo -e "${BOLD}QUICK DEVELOPMENT SETUP:${NC}"
    echo "1. Copy development environment file:"
    echo "   cp .env.dev .env"
    echo
    echo "2. Start development services:"
    echo "   prosody-manager deploy up"
    echo
    echo "3. Create test user:"
    echo "   prosody-manager prosodyctl adduser test@localhost"
    echo
    echo -e "${BOLD}DEVELOPMENT-SPECIFIC COMMANDS:${NC}"
    echo -e "  ${GREEN}# Use development compose file${NC}"
    echo "    docker compose -f docker-compose.dev.yml up -d"
    echo
    echo -e "  ${GREEN}# Enable debug logging${NC}"
    echo "    DEBUG=true prosody-manager health all"
    echo
    echo -e "  ${GREEN}# Test with self-signed certificates${NC}"
    echo "    prosody-manager cert install localhost"
    echo
    echo -e "  ${GREEN}# Quick module testing${NC}"
    echo "    prosody-manager module install mod_admin_web"
    echo "    prosody-manager prosodyctl reload"
    echo
    echo -e "${BOLD}🧪 TESTING TIPS:${NC}"
    echo "• Use localhost or *.localhost domains for testing"
    echo "• Self-signed certificates are fine for development"
    echo "• Enable debug mode: DEBUG=true in .env"
    echo "• Use Adminer (http://localhost:8080) for database access"
    echo "• Test XMPP clients: Gajim, Conversations, or web clients"
    echo
    echo -e "${BOLD}🔍 DEBUGGING:${NC}"
    echo "• View real-time logs: prosody-manager deploy logs prosody --follow"
    echo "• Check configuration: prosody-manager health config"
    echo "• Validate environment: prosody-manager health all"
    echo "• Container shell access: docker exec -it xmpp-prosody-dev bash"
    echo
    echo -e "${BOLD}⚠️  DEVELOPMENT WARNINGS:${NC}"
    echo "• Don't use development setup in production"
    echo "• Development uses weaker security settings"
    echo "• Database data persists between restarts"
    echo "• Self-signed certificates will show warnings in clients"
}

show_production_help() {
    echo -e "${BOLD}🏭 Production Environment Help${NC}"
    echo
    echo -e "${BOLD}PRODUCTION DEPLOYMENT CHECKLIST:${NC}"
    echo "□ 1. Configure proper domain name in .env"
    echo "□ 2. Set strong PostgreSQL password"
    echo "□ 3. Configure Let's Encrypt certificates"
    echo "□ 4. Set up proper DNS records"
    echo "□ 5. Configure firewall rules"
    echo "□ 6. Set up monitoring and backups"
    echo "□ 7. Test with XMPP clients"
    echo
    echo -e "${BOLD}SECURITY BEST PRACTICES:${NC}"
    echo -e "  ${GREEN}# Use strong passwords${NC}"
    echo "    POSTGRES_PASSWORD=\$(openssl rand -base64 32)"
    echo
    echo -e "  ${GREEN}# Enable Let's Encrypt${NC}"
    echo "    prosody-manager cert install your-domain.com"
    echo
    echo -e "  ${GREEN}# Regular security updates${NC}"
    echo "    prosody-manager module update"
    echo "    docker compose pull && docker compose up -d"
    echo
    echo -e "  ${GREEN}# Monitor certificate expiry${NC}"
    echo "    prosody-manager health certs"
    echo
    echo -e "${BOLD}🔒 REQUIRED DNS RECORDS:${NC}"
    echo "  A     your-domain.com           → your-server-ip"
    echo "  AAAA  your-domain.com           → your-server-ipv6"
    echo "  SRV   _xmpp-client._tcp         → 5 0 5222 your-domain.com"
    echo "  SRV   _xmpp-server._tcp         → 5 0 5269 your-domain.com"
    echo "  SRV   _xmpps-client._tcp        → 10 0 5223 your-domain.com"
    echo
    echo -e "${BOLD}🔥 FIREWALL CONFIGURATION:${NC}"
    echo "  Port 5222  (XMPP Client-to-Server)"
    echo "  Port 5269  (XMPP Server-to-Server)"
    echo "  Port 5280  (HTTP for file uploads)"
    echo "  Port 5281  (HTTPS for file uploads)"
    echo "  Port 80    (HTTP for Let's Encrypt)"
    echo "  Port 443   (HTTPS for web services)"
    echo
    echo -e "${BOLD}📊 MONITORING COMMANDS:${NC}"
    echo -e "  ${GREEN}# Regular health checks${NC}"
    echo "    prosody-manager health all"
    echo
    echo -e "  ${GREEN}# Monitor resource usage${NC}"
    echo "    prosody-manager deploy status"
    echo
    echo -e "  ${GREEN}# Check certificate expiry${NC}"
    echo "    prosody-manager cert check your-domain.com"
    echo
    echo -e "  ${GREEN}# View error logs${NC}"
    echo "    prosody-manager deploy logs prosody | grep ERROR"
    echo
    echo -e "${BOLD}💾 BACKUP STRATEGY:${NC}"
    echo "• Schedule regular backups: prosody-manager backup create"
    echo "• Test restore procedures regularly"
    echo "• Store backups off-site"
    echo "• Include database and certificates in backups"
    echo
    echo -e "${BOLD}🚨 EMERGENCY PROCEDURES:${NC}"
    echo -e "  ${GREEN}# Service recovery${NC}"
    echo "    prosody-manager deploy restart"
    echo "    prosody-manager health all"
    echo
    echo -e "  ${GREEN}# Certificate renewal${NC}"
    echo "    prosody-manager cert renew your-domain.com"
    echo
    echo -e "  ${GREEN}# Restore from backup${NC}"
    echo "    prosody-manager backup restore /path/to/backup.tar.gz"
    echo
    echo -e "${BOLD}⚠️  PRODUCTION WARNINGS:${NC}"
    echo "• Always test changes in development first"
    echo "• Schedule maintenance windows for updates"
    echo "• Monitor logs for security issues"
    echo "• Keep regular backups"
    echo "• Use strong, unique passwords"
}

# Command-specific help functions
show_command_help() {
    local command="$1"

    case "$command" in
        "prosodyctl")
            show_prosodyctl_help
            ;;
        "deploy")
            show_deploy_help
            ;;
        "module")
            module_help
            ;;
        "cert")
            show_cert_help
            ;;
        "backup")
            show_backup_help
            ;;
        "health")
            show_health_help
            ;;
        *)
            show_general_help
            ;;
    esac
}

show_prosodyctl_help() {
    echo -e "${BOLD}👤 User Management Help${NC}"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager prosodyctl <command> [options]"
    echo "    prosody-manager prosodyctl                    # Interactive mode"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "    ${GREEN}adduser <email> [password]${NC}    Add new user account"
    echo -e "    ${GREEN}deluser <email>${NC}               Delete user account"
    echo -e "    ${GREEN}passwd <email> [password]${NC}     Change user password"
    echo -e "    ${GREEN}status${NC}                        Show Prosody server status"
    echo -e "    ${GREEN}reload${NC}                        Reload configuration"
    echo -e "    ${GREEN}restart${NC}                       Restart Prosody service"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    prosody-manager prosodyctl adduser alice@chat.example.com"
    echo "    prosody-manager prosodyctl passwd alice@chat.example.com newpassword"
    echo "    prosody-manager prosodyctl deluser alice@chat.example.com"
    echo "    prosody-manager prosodyctl status"
}

show_deploy_help() {
    echo -e "${BOLD}🚀 Deployment Help${NC}"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager deploy <command> [options]"
    echo "    prosody-manager deploy                        # Interactive mode"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "    ${GREEN}up [minimal|full]${NC}             Start services"
    echo -e "    ${GREEN}down${NC}                          Stop all services"
    echo -e "    ${GREEN}restart [service]${NC}             Restart services"
    echo -e "    ${GREEN}logs [service] [--follow]${NC}     View service logs"
    echo -e "    ${GREEN}status${NC}                        Show service status"
    echo
    echo -e "${BOLD}DEPLOYMENT MODES:${NC}"
    echo -e "    ${CYAN}full${NC}     - All services (Prosody, PostgreSQL, Coturn, etc.)"
    echo -e "    ${CYAN}minimal${NC}  - Prosody only (for testing)"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    prosody-manager deploy up full"
    echo "    prosody-manager deploy logs prosody --follow"
    echo "    prosody-manager deploy restart prosody"
    echo "    prosody-manager deploy status"
}

show_cert_help() {
    echo -e "${BOLD}🔒 Certificate Management Help${NC}"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager cert <command> [options]"
    echo "    prosody-manager cert                          # Interactive mode"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "    ${GREEN}check <domain>${NC}                Check certificate status and expiry"
    echo -e "    ${GREEN}install <domain> [path]${NC}       Install certificate (or generate self-signed)"
    echo -e "    ${GREEN}renew <domain>${NC}                Renew Let's Encrypt certificate"
    echo -e "    ${GREEN}monitor${NC}                       Run certificate monitoring check"
    echo -e "    ${GREEN}auto-renew${NC}                    Auto-renew certificates if needed"
    echo -e "    ${GREEN}dashboard${NC}                     Generate certificate health dashboard"
    echo -e "    ${GREEN}status${NC}                        Show certificate monitoring status"
    echo
    echo -e "${BOLD}CERTIFICATE TYPES:${NC}"
    echo -e "    ${CYAN}Let's Encrypt${NC}  - Free, automated, trusted certificates"
    echo -e "    ${CYAN}Self-signed${NC}   - For development and testing"
    echo -e "    ${CYAN}Custom${NC}        - Your own certificates"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    prosody-manager cert check chat.example.com"
    echo "    prosody-manager cert install chat.example.com"
    echo "    prosody-manager cert renew chat.example.com"
}

show_backup_help() {
    echo -e "${BOLD}💾 Backup Management Help${NC}"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager backup <command> [options]"
    echo "    prosody-manager backup                        # Interactive mode"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "    ${GREEN}create [name]${NC}                 Create new backup"
    echo -e "    ${GREEN}restore <backup_file>${NC}         Restore from backup"
    echo -e "    ${GREEN}list${NC}                          List available backups"
    echo
    echo -e "${BOLD}BACKUP INCLUDES:${NC}"
    echo "• Configuration files"
    echo "• Prosody data and user accounts"
    echo "• PostgreSQL database"
    echo "• SSL certificates"
    echo "• Docker configuration"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    prosody-manager backup create daily_backup"
    echo "    prosody-manager backup list"
    echo "    prosody-manager backup restore /path/to/backup.tar.gz"
}

show_health_help() {
    echo -e "${BOLD}🏥 Health Monitoring Help${NC}"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager health [check_type]"
    echo
    echo -e "${BOLD}CHECK TYPES:${NC}"
    echo -e "    ${GREEN}all${NC}         Run all health checks (default)"
    echo -e "    ${GREEN}process${NC}     Check if Prosody is running"
    echo -e "    ${GREEN}ports${NC}       Check if required ports are listening"
    echo -e "    ${GREEN}config${NC}      Validate Prosody configuration"
    echo -e "    ${GREEN}certs${NC}       Check certificate status and expiry"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    prosody-manager health"
    echo "    prosody-manager health certs"
    echo "    prosody-manager health config"
}

# ============================================================================
# BASH COMPLETION SUPPORT
# ============================================================================

generate_completion_script() {
    cat << 'EOF'
#!/bin/bash
# Bash completion for prosody-manager

_prosody_manager_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Main commands
    local main_commands="setup prosodyctl health cert backup deploy module dev help version"
    
    # Subcommands for each main command
    local prosodyctl_commands="adduser deluser passwd status reload restart cert"
    local health_commands="all process ports config certs"
    local cert_commands="check install renew"
    local backup_commands="create restore list"
    local deploy_commands="up down restart logs status"
    local module_commands="list search install remove update info sync rocks help"
    local module_rocks_commands="install remove list outdated help"
    local dev_commands="status urls test config users adduser deluser passwd logs restart cleanup backup perf help"

    case "${COMP_CWORD}" in
        1)
            # Complete main commands
            COMPREPLY=($(compgen -W "${main_commands}" -- ${cur}))
            return 0
            ;;
        2)
            # Complete subcommands based on main command
            case "${prev}" in
                prosodyctl)
                    COMPREPLY=($(compgen -W "${prosodyctl_commands}" -- ${cur}))
                    ;;
                health)
                    COMPREPLY=($(compgen -W "${health_commands}" -- ${cur}))
                    ;;
                cert)
                    COMPREPLY=($(compgen -W "${cert_commands}" -- ${cur}))
                    ;;
                backup)
                    COMPREPLY=($(compgen -W "${backup_commands}" -- ${cur}))
                    ;;
                deploy)
                    COMPREPLY=($(compgen -W "${deploy_commands}" -- ${cur}))
                    ;;
                module)
                    COMPREPLY=($(compgen -W "${module_commands}" -- ${cur}))
                    ;;
                dev)
                    COMPREPLY=($(compgen -W "${dev_commands}" -- ${cur}))
                    ;;
                help)
                    COMPREPLY=($(compgen -W "dev prod" -- ${cur}))
                    ;;
            esac
            ;;
        3)
            # Complete third-level commands
            case "${COMP_WORDS[1]}" in
                module)
                    case "${prev}" in
                        rocks)
                            COMPREPLY=($(compgen -W "${module_rocks_commands}" -- ${cur}))
                            ;;
                        restore)
                            # Complete with .tar.gz files
                            COMPREPLY=($(compgen -f -X "!*.tar.gz" -- ${cur}))
                            ;;
                    esac
                    ;;
                deploy)
                    case "${prev}" in
                        up)
                            COMPREPLY=($(compgen -W "minimal full" -- ${cur}))
                            ;;
                        logs)
                            # Complete with service names
                            COMPREPLY=($(compgen -W "prosody postgres coturn adminer" -- ${cur}))
                            ;;
                        restart)
                            COMPREPLY=($(compgen -W "prosody postgres coturn adminer" -- ${cur}))
                            ;;
                    esac
                    ;;
                backup)
                    case "${prev}" in
                        restore)
                            # Complete with .tar.gz files
                            COMPREPLY=($(compgen -f -X "!*.tar.gz" -- ${cur}))
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac

    return 0
}

# Register the completion function
complete -F _prosody_manager_completion prosody-manager
EOF
}

install_completion() {
    local completion_dir
    local completion_file

    # Try different completion directories
    for dir in "/etc/bash_completion.d" "/usr/share/bash-completion/completions" "$HOME/.bash_completion.d"; do
        if [[ -d "$dir" ]] || [[ "$dir" == "$HOME/.bash_completion.d" ]]; then
            completion_dir="$dir"
            break
        fi
    done

    if [[ -z "$completion_dir" ]]; then
        # Create user completion directory
        completion_dir="$HOME/.bash_completion.d"
        mkdir -p "$completion_dir"
    fi

    completion_file="$completion_dir/prosody-manager"

    log_info "Installing bash completion to: $completion_file"

    if generate_completion_script > "$completion_file"; then
        chmod +x "$completion_file"
        log_success "Bash completion installed successfully"
        echo -e "${YELLOW}💡 Note:${NC} Restart your shell or run 'source $completion_file' to enable completion"

        # Add to .bashrc if it's a user directory
        if [[ "$completion_dir" == "$HOME/.bash_completion.d" ]]; then
            local bashrc="$HOME/.bashrc"
            if [[ -f "$bashrc" ]] && ! grep -q "prosody-manager" "$bashrc"; then
                {
                    echo ""
                    echo "# Prosody Manager completion"
                    echo "source $completion_file"
                } >> "$bashrc"
                log_info "Added completion source to ~/.bashrc"
            fi
        fi
    else
        error_with_guidance "Failed to install bash completion" \
            "Check write permissions for $completion_dir" \
            "$EXIT_PERMISSION_ERROR"
        return "$EXIT_PERMISSION_ERROR"
    fi
}

show_version() {
    echo "Prosody Manager v${VERSION}"
}

main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        "setup")
            interactive_setup
            ;;
        "prosodyctl")
            if [[ $# -eq 0 ]]; then
                # Interactive mode if no arguments
                local action
                action=$(select_option "Choose prosodyctl action:" \
                    "Add user" \
                    "Delete user" \
                    "Change password" \
                    "Show status" \
                    "Reload configuration" \
                    "Certificate management")

                case "$action" in
                    "Add user")
                        interactive_user_creation
                        ;;
                    "Delete user")
                        local user
                        user=$(input_with_validation "Enter user email to delete" \
                            "validate_email" \
                            "Please enter a valid email address")
                        prosodyctl_command "deluser" "$user"
                        ;;
                    "Change password")
                        local user
                        user=$(input_with_validation "Enter user email" \
                            "validate_email" \
                            "Please enter a valid email address")
                        prosodyctl_command "passwd" "$user"
                        ;;
                    "Show status")
                        prosodyctl_command "status"
                        ;;
                    "Reload configuration")
                        prosodyctl_command "reload"
                        ;;
                    "Certificate management")
                        prosodyctl_command "cert"
                        ;;
                esac
            else
                prosodyctl_command "$@"
            fi
            ;;
        "health")
            health_check "$@"
            ;;
        "cert" | "certificate" | "certificates")
            if [[ $# -eq 0 ]]; then
                # Interactive certificate management
                local action
                action=$(select_option "Choose certificate action:" \
                    "Check certificate status" \
                    "Install certificate" \
                    "Renew certificate" \
                    "Monitor certificates" \
                    "Auto-renew certificates" \
                    "Generate health dashboard" \
                    "Show monitoring status")

                case "$action" in
                    "Check certificate status")
                        local domain
                        domain=$(input_with_validation "Enter domain to check" \
                            "validate_domain" \
                            "Please enter a valid domain name")
                        cert_command "check" "$domain"
                        ;;
                    "Install certificate")
                        local domain
                        domain=$(input_with_validation "Enter domain" \
                            "validate_domain" \
                            "Please enter a valid domain name")
                        local cert_path
                        read -p "Enter certificate path (or press Enter for self-signed): " cert_path
                        cert_command "install" "$domain" "$cert_path"
                        ;;
                    "Renew certificate")
                        local domain
                        domain=$(input_with_validation "Enter domain to renew" \
                            "validate_domain" \
                            "Please enter a valid domain name")
                        cert_command "renew" "$domain"
                        ;;
                    "Monitor certificates")
                        cert_command "monitor"
                        ;;
                    "Auto-renew certificates")
                        cert_command "auto-renew"
                        ;;
                    "Generate health dashboard")
                        cert_command "dashboard"
                        ;;
                    "Show monitoring status")
                        cert_command "status"
                        ;;
                esac
            else
                cert_command "$@"
            fi
            ;;
        "backup")
            if [[ $# -eq 0 ]]; then
                interactive_backup
            else
                backup_command "$@"
            fi
            ;;
        "deploy")
            if [[ $# -eq 0 ]]; then
                interactive_deploy
            else
                deploy_command "$@"
            fi
            ;;
        "module")
            if [[ $# -eq 0 ]]; then
                # Interactive module management
                local action
                action=$(select_option "Choose module action:" \
                    "List installed modules" \
                    "Search for modules" \
                    "Install module" \
                    "Remove module" \
                    "Update modules" \
                    "Show module info")

                case "$action" in
                    "List installed modules")
                        module_command "list"
                        ;;
                    "Search for modules")
                        local query
                        read -p "Enter search term: " query
                        if [[ -n "$query" ]]; then
                            module_command "search" "$query"
                        fi
                        ;;
                    "Install module")
                        local module
                        read -p "Enter module name: " module
                        if [[ -n "$module" ]]; then
                            local install_type
                            install_type=$(select_option "Choose installation method:" \
                                "Community module (manual dependencies)" \
                                "Official module (automatic dependencies)")

                            case "$install_type" in
                                "Community module"*)
                                    module_command "install" "$module"
                                    ;;
                                "Official module"*)
                                    module_command "rocks" "install" "$module"
                                    ;;
                            esac
                        fi
                        ;;
                    "Remove module")
                        local module
                        read -p "Enter module name to remove: " module
                        if [[ -n "$module" ]]; then
                            module_command "remove" "$module"
                        fi
                        ;;
                    "Update modules")
                        module_command "update"
                        ;;
                    "Show module info")
                        local module
                        read -p "Enter module name: " module
                        if [[ -n "$module" ]]; then
                            module_command "info" "$module"
                        fi
                        ;;
                esac
            else
                module_command "$@"
            fi
            ;;
        "dev")
            if [[ $# -eq 0 ]]; then
                # Interactive development mode
                local action
                action=$(select_option "Choose development action:" \
                    "Show environment status" \
                    "Show access URLs" \
                    "Test connectivity" \
                    "Test configuration" \
                    "List users" \
                    "Add user" \
                    "Delete user" \
                    "Change password" \
                    "Show logs" \
                    "Restart service" \
                    "Backup data" \
                    "Performance test" \
                    "Clean up environment")

                case "$action" in
                    "Show environment status")
                        dev_command "status"
                        ;;
                    "Show access URLs")
                        dev_command "urls"
                        ;;
                    "Test connectivity")
                        dev_command "test"
                        ;;
                    "Test configuration")
                        dev_command "config"
                        ;;
                    "List users")
                        dev_command "users"
                        ;;
                    "Add user")
                        local username
                        read -p "Enter username (without @localhost): " username
                        if [[ -n "$username" ]]; then
                            local password
                            read -s -p "Enter password (or press Enter to prompt): " password
                            echo
                            if [[ -n "$password" ]]; then
                                dev_command "adduser" "$username" "$password"
                            else
                                dev_command "adduser" "$username"
                            fi
                        fi
                        ;;
                    "Delete user")
                        local username
                        read -p "Enter username to delete (without @localhost): " username
                        if [[ -n "$username" ]]; then
                            dev_command "deluser" "$username"
                        fi
                        ;;
                    "Change password")
                        local username
                        read -p "Enter username (without @localhost): " username
                        if [[ -n "$username" ]]; then
                            dev_command "passwd" "$username"
                        fi
                        ;;
                    "Show logs")
                        local service
                        read -p "Enter service name (or press Enter for all): " service
                        local lines
                        read -p "Enter number of lines (default 50): " lines
                        dev_command "logs" "$service" "${lines:-50}"
                        ;;
                    "Restart service")
                        local service
                        read -p "Enter service name (default: xmpp-prosody-dev): " service
                        dev_command "restart" "${service:-xmpp-prosody-dev}"
                        ;;
                    "Backup data")
                        dev_command "backup"
                        ;;
                    "Performance test")
                        dev_command "perf"
                        ;;
                    "Clean up environment")
                        dev_command "cleanup"
                        ;;
                esac
            else
                dev_command "$@"
            fi
            ;;
        "completion")
            local action="${1:-install}"
            case "$action" in
                "install")
                    install_completion
                    ;;
                "generate")
                    generate_completion_script
                    ;;
                *)
                    echo "Usage: prosody-manager completion [install|generate]"
                    echo "  install   - Install bash completion system-wide"
                    echo "  generate  - Generate completion script to stdout"
                    ;;
            esac
            ;;
        "help" | "-h" | "--help")
            local help_context="${1:-general}"
            show_help "$help_context"
            ;;
        "version" | "-v" | "--version")
            show_version
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            echo -e "${YELLOW}💡 Tip:${NC} Run 'prosody-manager help' for available commands"
            echo -e "${YELLOW}💡 Tip:${NC} Run commands without arguments for interactive mode"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
