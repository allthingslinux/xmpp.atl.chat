#!/bin/bash
set -euo pipefail

# ============================================================================
# PROSODY MANAGER - Unified CLI Tool
# ============================================================================
# Comprehensive management tool for Prosody XMPP Server
# Consolidates multiple management scripts into a single interface

readonly VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
readonly PROJECT_DIR
readonly CONFIG_DIR="$PROJECT_DIR/config"
readonly DOCKER_DIR="$PROJECT_DIR/docker"

# ============================================================================
# COLORS AND FORMATTING
# ============================================================================

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        echo -e "${CYAN}[DEBUG]${NC} $1"
    fi
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

is_docker_environment() {
    [[ -f /.dockerenv ]] || grep -q docker /proc/1/cgroup 2>/dev/null
}

get_container_name() {
    if is_docker_environment; then
        echo "prosody"
    else
        # Dynamically detect the correct container name
        local container_name

        # Try different possible container names in order of preference
        for name in "xmpp-prosody-dev" "xmpp-prosody-1" "xmpp-prosody"; do
            if docker ps --format "{{.Names}}" | grep -q "^${name}$"; then
                echo "$name"
                return 0
            fi
        done

        # Fallback: find any running container with prosody in the name
        container_name=$(docker ps --format "{{.Names}}" | grep prosody | head -1)
        if [[ -n "$container_name" ]]; then
            echo "$container_name"
            return 0
        fi

        # Last resort: default name
        echo "xmpp-prosody-1"
    fi
}

run_in_container() {
    local container_name
    container_name=$(get_container_name)

    if is_docker_environment; then
        # Already in container, run directly
        "$@"
    else
        # Run in container
        docker exec -it "$container_name" "$@"
    fi
}

# ============================================================================
# PROSODYCTL MANAGEMENT
# ============================================================================

prosodyctl_command() {
    local cmd="$1"
    shift

    case "$cmd" in
    "adduser" | "user")
        if [[ $# -lt 1 ]]; then
            log_error "Usage: prosody-manager prosodyctl adduser <user@domain> [password]"
            return 1
        fi
        local user="$1"
        local password="${2:-}"

        if [[ -z "$password" ]]; then
            run_in_container prosodyctl adduser "$user"
        else
            echo "$password" | run_in_container prosodyctl adduser "$user"
        fi
        ;;
    "deluser")
        if [[ $# -lt 1 ]]; then
            log_error "Usage: prosody-manager prosodyctl deluser <user@domain>"
            return 1
        fi
        run_in_container prosodyctl deluser "$1"
        ;;
    "passwd")
        if [[ $# -lt 1 ]]; then
            log_error "Usage: prosody-manager prosodyctl passwd <user@domain> [password]"
            return 1
        fi
        local user="$1"
        local password="${2:-}"

        if [[ -z "$password" ]]; then
            run_in_container prosodyctl passwd "$user"
        else
            echo "$password" | run_in_container prosodyctl passwd "$user"
        fi
        ;;
    "status")
        run_in_container prosodyctl status
        ;;
    "reload")
        run_in_container prosodyctl reload
        ;;
    "restart")
        if is_docker_environment; then
            log_warn "In Docker, use 'docker compose restart prosody' instead"
            return 1
        else
            docker compose -f "$DOCKER_DIR/docker-compose.yml" restart prosody
        fi
        ;;
    "cert")
        local subcmd="${1:-list}"
        shift || true

        case "$subcmd" in
        "import")
            if [[ $# -lt 1 ]]; then
                log_error "Usage: prosody-manager prosodyctl cert import <domain> [cert_path]"
                return 1
            fi
            run_in_container prosodyctl cert import "$@"
            ;;
        "generate")
            if [[ $# -lt 1 ]]; then
                log_error "Usage: prosody-manager prosodyctl cert generate <domain>"
                return 1
            fi
            run_in_container prosodyctl cert generate "$@"
            ;;
        "list" | *)
            run_in_container prosodyctl cert list
            ;;
        esac
        ;;
    *)
        run_in_container prosodyctl "$cmd" "$@"
        ;;
    esac
}

# ============================================================================
# HEALTH CHECK FUNCTIONS
# ============================================================================

health_check() {
    local check_type="${1:-all}"
    local exit_code=0

    log_info "Running Prosody health check..."

    case "$check_type" in
    "process" | "all")
        if ! check_process; then
            exit_code=1
        fi
        ;;
    esac

    case "$check_type" in
    "ports" | "all")
        if ! check_ports; then
            exit_code=1
        fi
        ;;
    esac

    case "$check_type" in
    "config" | "all")
        if ! check_config; then
            exit_code=1
        fi
        ;;
    esac

    case "$check_type" in
    "certs" | "certificates" | "all")
        if ! check_certificates_health; then
            exit_code=1
        fi
        ;;
    esac

    if [[ $exit_code -eq 0 ]]; then
        log_success "All health checks passed"
    else
        log_error "Some health checks failed"
    fi

    return $exit_code
}

check_process() {
    log_info "Checking Prosody process..."

    if run_in_container prosodyctl status >/dev/null 2>&1; then
        log_success "Prosody is running"
        return 0
    else
        log_error "Prosody process not running"
        return 1
    fi
}

check_ports() {
    local ports=(5222 5269 5280)
    local failed=0

    log_info "Checking port availability..."

    for port in "${ports[@]}"; do
        if run_in_container ss -tlnp | grep -q ":$port "; then
            log_success "Port $port is listening"
        else
            log_error "Port $port is not listening"
            ((failed++))
        fi
    done

    return $failed
}

check_config() {
    log_info "Checking configuration..."

    if run_in_container prosodyctl check config >/dev/null 2>&1; then
        log_success "Configuration is valid"
        return 0
    else
        log_error "Configuration validation failed"
        run_in_container prosodyctl check config
        return 1
    fi
}

check_certificates_health() {
    local domain="${PROSODY_DOMAIN:-localhost}"
    local warning_days=30
    local critical_days=7
    local failed=0

    log_info "Checking certificates for domain: $domain"

    # Check if certificate exists
    if ! run_in_container test -f "/etc/prosody/certs/$domain.crt"; then
        log_error "Certificate not found for domain: $domain"
        return 1
    fi

    # Check certificate expiry
    local expiry_date
    if expiry_date=$(run_in_container openssl x509 -in "/etc/prosody/certs/$domain.crt" -noout -enddate 2>/dev/null | cut -d= -f2); then
        local expiry_epoch
        expiry_epoch=$(date -d "$expiry_date" +%s)
        local current_epoch
        current_epoch=$(date +%s)
        local days_until_expiry=$(((expiry_epoch - current_epoch) / 86400))

        if [[ $days_until_expiry -lt $critical_days ]]; then
            log_error "Certificate expires in $days_until_expiry days (critical)"
            failed=1
        elif [[ $days_until_expiry -lt $warning_days ]]; then
            log_warn "Certificate expires in $days_until_expiry days (warning)"
        else
            log_success "Certificate expires in $days_until_expiry days"
        fi
    else
        log_error "Could not read certificate expiry date"
        failed=1
    fi

    return $failed
}

# ============================================================================
# CERTIFICATE MANAGEMENT
# ============================================================================

cert_command() {
    local cmd="$1"
    shift

    case "$cmd" in
    "check")
        local domain="${1:-${PROSODY_DOMAIN:-}}"
        if [[ -z "$domain" ]]; then
            log_error "Domain required. Usage: prosody-manager cert check <domain>"
            return 1
        fi
        check_certificates_detailed "$domain"
        ;;
    "install")
        local domain="${1:-}"
        local cert_path="${2:-}"
        if [[ -z "$domain" ]]; then
            log_error "Domain required. Usage: prosody-manager cert install <domain> [cert_path]"
            return 1
        fi
        install_certificate "$domain" "$cert_path"
        ;;
    "renew")
        local domain="${1:-${PROSODY_DOMAIN:-}}"
        if [[ -z "$domain" ]]; then
            log_error "Domain required. Usage: prosody-manager cert renew <domain>"
            return 1
        fi
        renew_certificate "$domain"
        ;;
    *)
        log_error "Unknown certificate command: $cmd"
        log_info "Available commands: check, install, renew"
        return 1
        ;;
    esac
}

check_certificates_detailed() {
    local domain="$1"
    local cert_file="/etc/prosody/certs/$domain.crt"
    local key_file="/etc/prosody/certs/$domain.key"

    log_info "Detailed certificate check for domain: $domain"

    # Check certificate file exists
    if run_in_container test -f "$cert_file"; then
        log_success "Certificate file exists: $cert_file"
    else
        log_error "Certificate file not found: $cert_file"
        return 1
    fi

    # Check key file exists
    if run_in_container test -f "$key_file"; then
        log_success "Private key file exists: $key_file"
    else
        log_error "Private key file not found: $key_file"
        return 1
    fi

    # Check certificate details
    log_info "Certificate details:"
    run_in_container openssl x509 -in "$cert_file" -noout -subject -issuer -dates -fingerprint

    # Check certificate chain
    log_info "Verifying certificate chain..."
    if run_in_container openssl verify "$cert_file" >/dev/null 2>&1; then
        log_success "Certificate chain is valid"
    else
        log_warn "Certificate chain verification failed (may be self-signed)"
    fi

    return 0
}

install_certificate() {
    local domain="$1"
    local cert_path="$2"

    if [[ -n "$cert_path" ]]; then
        log_info "Installing certificate from: $cert_path"
        # Copy certificate files to container
        docker cp "$cert_path/$domain.crt" "$(get_container_name):/etc/prosody/certs/"
        docker cp "$cert_path/$domain.key" "$(get_container_name):/etc/prosody/certs/"
    else
        log_info "Generating self-signed certificate for domain: $domain"
        run_in_container prosodyctl cert generate "$domain"
    fi

    # Set proper permissions
    run_in_container chown prosody:prosody "/etc/prosody/certs/$domain.crt" "/etc/prosody/certs/$domain.key"
    run_in_container chmod 644 "/etc/prosody/certs/$domain.crt"
    run_in_container chmod 600 "/etc/prosody/certs/$domain.key"

    # Reload Prosody to use new certificate
    run_in_container prosodyctl reload

    log_success "Certificate installed for domain: $domain"
}

renew_certificate() {
    local domain="$1"

    log_info "Renewing certificate for domain: $domain"

    # Check if using Let's Encrypt
    if run_in_container test -f "/etc/letsencrypt/live/$domain/fullchain.pem"; then
        log_info "Renewing Let's Encrypt certificate..."
        run_in_container xmpp-certbot renew --cert-name "$domain"

        # Copy renewed certificate
        run_in_container cp "/etc/letsencrypt/live/$domain/fullchain.pem" "/etc/prosody/certs/$domain.crt"
        run_in_container cp "/etc/letsencrypt/live/$domain/privkey.pem" "/etc/prosody/certs/$domain.key"

        # Set permissions
        run_in_container chown prosody:prosody "/etc/prosody/certs/$domain.crt" "/etc/prosody/certs/$domain.key"
        run_in_container chmod 644 "/etc/prosody/certs/$domain.crt"
        run_in_container chmod 600 "/etc/prosody/certs/$domain.key"

        # Reload Prosody
        run_in_container prosodyctl reload

        log_success "Let's Encrypt certificate renewed for domain: $domain"
    else
        log_warn "Let's Encrypt certificate not found. Generating new self-signed certificate..."
        install_certificate "$domain"
    fi
}

# ============================================================================
# BACKUP MANAGEMENT
# ============================================================================

backup_command() {
    local cmd="${1:-create}"
    shift || true

    case "$cmd" in
    "create")
        create_backup "$@"
        ;;
    "restore")
        restore_backup "$@"
        ;;
    "list")
        list_backups
        ;;
    *)
        log_error "Unknown backup command: $cmd"
        log_info "Available commands: create, restore, list"
        return 1
        ;;
    esac
}

create_backup() {
    local backup_name
    backup_name="${1:-prosody_backup_$(date +%Y%m%d_%H%M%S)}"
    local backup_dir="${BACKUP_DIR:-$PROJECT_DIR/backups}"
    local backup_path="$backup_dir/$backup_name"

    log_info "Creating backup: $backup_name"

    # Create backup directory
    mkdir -p "$backup_path"

    # Backup configuration
    log_info "Backing up configuration..."
    cp -r "$CONFIG_DIR" "$backup_path/"

    # Backup Docker configuration
    log_info "Backing up Docker configuration..."
    cp -r "$DOCKER_DIR" "$backup_path/"

    # Backup Prosody data from container
    if ! is_docker_environment && docker ps --format '{{.Names}}' | grep -q "prosody"; then
        log_info "Backing up Prosody data from container..."
        mkdir -p "$backup_path/prosody-data"

        # Backup data directory
        docker cp "$(get_container_name):/var/lib/prosody/data" "$backup_path/prosody-data/"

        # Backup certificates
        docker cp "$(get_container_name):/etc/prosody/certs" "$backup_path/prosody-data/"

        # Backup database (if PostgreSQL)
        if docker ps --format '{{.Names}}' | grep -q "db"; then
            log_info "Backing up PostgreSQL database..."
            docker exec xmpp-postgres pg_dump -U prosody prosody >"$backup_path/database.sql"
        fi
    fi

    # Create archive
    log_info "Creating backup archive..."
    cd "$backup_dir"
    tar -czf "${backup_name}.tar.gz" "$backup_name"
    rm -rf "$backup_name"

    log_success "Backup created: $backup_dir/${backup_name}.tar.gz"
}

restore_backup() {
    local backup_file="$1"

    if [[ -z "$backup_file" ]]; then
        log_error "Backup file required. Usage: prosody-manager backup restore <backup_file>"
        return 1
    fi

    if [[ ! -f "$backup_file" ]]; then
        log_error "Backup file not found: $backup_file"
        return 1
    fi

    log_warn "This will restore from backup and may overwrite current data."
    read -p "Continue? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Restore cancelled"
        return 0
    fi

    log_info "Restoring from backup: $backup_file"

    # Extract backup
    local temp_dir
    temp_dir=$(mktemp -d)
    tar -xzf "$backup_file" -C "$temp_dir"

    local backup_name
    backup_name=$(basename "$backup_file" .tar.gz)
    local backup_path="$temp_dir/$backup_name"

    # Stop services
    if ! is_docker_environment; then
        log_info "Stopping services..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" down
    fi

    # Restore configuration
    if [[ -d "$backup_path/config" ]]; then
        log_info "Restoring configuration..."
        cp -r "$backup_path/config"/* "$CONFIG_DIR/"
    fi

    # Restore Docker configuration
    if [[ -d "$backup_path/docker" ]]; then
        log_info "Restoring Docker configuration..."
        cp -r "$backup_path/docker"/* "$DOCKER_DIR/"
    fi

    # Restore Prosody data
    if [[ -d "$backup_path/prosody-data" ]] && ! is_docker_environment; then
        log_info "Starting services to restore data..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" up -d

        # Wait for services to start
        sleep 10

        # Restore data
        if [[ -d "$backup_path/prosody-data/data" ]]; then
            docker cp "$backup_path/prosody-data/data" "$(get_container_name):/var/lib/prosody/"
        fi

        if [[ -d "$backup_path/prosody-data/certs" ]]; then
            docker cp "$backup_path/prosody-data/certs" "$(get_container_name):/etc/prosody/"
        fi

        # Restore database
        if [[ -f "$backup_path/database.sql" ]]; then
            log_info "Restoring database..."
            docker exec -i xmpp-postgres psql -U prosody prosody <"$backup_path/database.sql"
        fi
    fi

    # Cleanup
    rm -rf "$temp_dir"

    if ! is_docker_environment; then
        log_info "Restarting services..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" restart
    fi

    log_success "Backup restored successfully"
}

list_backups() {
    local backup_dir="${BACKUP_DIR:-$PROJECT_DIR/backups}"

    if [[ ! -d "$backup_dir" ]]; then
        log_info "No backup directory found: $backup_dir"
        return 0
    fi

    log_info "Available backups in $backup_dir:"

    if find "$backup_dir" -name "*.tar.gz" -type f | head -1 >/dev/null 2>&1; then
        find "$backup_dir" -name "*.tar.gz" -type f -exec ls -lah {} \; | while read -r line; do
            echo "  $line"
        done
    else
        log_info "No backups found"
    fi
}

# ============================================================================
# DEPLOYMENT MANAGEMENT
# ============================================================================

deploy_command() {
    local cmd="${1:-up}"
    shift || true

    case "$cmd" in
    "up" | "start")
        deploy_up "$@"
        ;;
    "down" | "stop")
        deploy_down "$@"
        ;;
    "restart")
        deploy_restart "$@"
        ;;
    "logs")
        deploy_logs "$@"
        ;;
    "status")
        deploy_status
        ;;
    *)
        log_error "Unknown deploy command: $cmd"
        log_info "Available commands: up, down, restart, logs, status"
        return 1
        ;;
    esac
}

deploy_up() {
    local mode="${1:-full}"

    log_info "Deploying Prosody XMPP server (mode: $mode)..."

    # Check prerequisites
    if ! command_exists docker; then
        log_error "Docker is required but not installed"
        return 1
    fi

    if ! docker compose version >/dev/null 2>&1; then
        log_error "Docker Compose is required but not installed"
        return 1
    fi

    # Check for .env file
    if [[ ! -f "$PROJECT_DIR/.env" ]]; then
        log_warn "No .env file found. Creating from example..."
        if [[ -f "$PROJECT_DIR/examples/env.example" ]]; then
            cp "$PROJECT_DIR/examples/env.example" "$PROJECT_DIR/.env"
            log_info "Please edit .env file with your configuration"
            return 1
        else
            log_error "No .env example file found"
            return 1
        fi
    fi

    # Deploy based on mode
    case "$mode" in
    "minimal")
        log_info "Starting minimal deployment (Prosody only)..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" up -d xmpp-prosody
        ;;
    "full" | *)
        log_info "Starting full deployment (all services)..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" up -d
        ;;
    esac

    # Wait for services to be ready
    log_info "Waiting for services to be ready..."
    sleep 10

    # Run health check
    if health_check >/dev/null 2>&1; then
        log_success "Deployment successful! Services are healthy."
    else
        log_warn "Deployment completed but some health checks failed."
        log_info "Run 'prosody-manager health' for detailed status."
    fi
}

deploy_down() {
    log_info "Stopping Prosody XMPP server..."
    docker compose -f "$DOCKER_DIR/docker-compose.yml" down "$@"
    log_success "Services stopped"
}

deploy_restart() {
    local service="${1:-}"

    if [[ -n "$service" ]]; then
        log_info "Restarting service: $service"
        docker compose -f "$DOCKER_DIR/docker-compose.yml" restart "$service"
    else
        log_info "Restarting all services..."
        docker compose -f "$DOCKER_DIR/docker-compose.yml" restart
    fi

    log_success "Services restarted"
}

deploy_logs() {
    local service="${1:-}"
    local args=("${@:2}")

    if [[ -n "$service" ]]; then
        docker compose -f "$DOCKER_DIR/docker-compose.yml" logs "${args[@]}" "$service"
    else
        docker compose -f "$DOCKER_DIR/docker-compose.yml" logs "${args[@]}"
    fi
}

deploy_status() {
    log_info "Service status:"
    docker compose -f "$DOCKER_DIR/docker-compose.yml" ps

    echo
    log_info "Resource usage:"
    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"
}

# ============================================================================
# MODULE MANAGEMENT FUNCTIONS
# ============================================================================

readonly MODULES_DIR="/usr/local/lib/prosody/modules"
readonly MODULES_REPO="https://hg.prosody.im/prosody-modules/"
readonly TEMP_MODULES_DIR="$PROJECT_DIR/.prosody-modules"
readonly ROCKS_SERVER="https://modules.prosody.im/rocks/"

module_command() {
    local subcommand="${1:-help}"
    shift || true

    case "$subcommand" in
    "list")
        module_list "$@"
        ;;
    "search")
        module_search "$@"
        ;;
    "install")
        module_install "$@"
        ;;
    "remove")
        module_remove "$@"
        ;;
    "update")
        module_update "$@"
        ;;
    "info")
        module_info "$@"
        ;;
    "sync")
        module_sync "$@"
        ;;
    "rocks")
        module_rocks "$@"
        ;;
    "help" | "-h" | "--help")
        module_help
        ;;
    *)
        log_error "Unknown module subcommand: $subcommand"
        echo
        module_help
        exit 1
        ;;
    esac
}

module_list() {
    local filter="${1:-}"
    local show_rocks="${2:-false}"

    log_info "Installed modules:"

    # List manually installed modules (from community repo)
    if [[ -d "$MODULES_DIR" ]]; then
        local count=0
        echo -e "${BOLD}Community Modules (from prosody-modules):${NC}"
        for module_dir in "$MODULES_DIR"/mod_*; do
            if [[ -d "$module_dir" ]]; then
                local module_name
                module_name=$(basename "$module_dir")
                if [[ -z "$filter" || "$module_name" == *"$filter"* ]]; then
                    echo -e "  ${GREEN}✓${NC} $module_name ${CYAN}(community)${NC}"
                    ((count++))
                fi
            fi
        done

        if [[ $count -eq 0 ]]; then
            echo -e "  ${YELLOW}No community modules installed${NC}"
        fi
        echo
    fi

    # List LuaRocks installed modules (via prosodyctl install)
    echo -e "${BOLD}Official Modules (via LuaRocks):${NC}"
    if command_exists prosodyctl; then
        if run_in_container prosodyctl list 2>/dev/null | grep -q "mod_"; then
            run_in_container prosodyctl list 2>/dev/null | grep "mod_" | while read -r line; do
                if [[ -z "$filter" || "$line" == *"$filter"* ]]; then
                    echo -e "  ${GREEN}✓${NC} $line ${BLUE}(official)${NC}"
                fi
            done
        else
            echo -e "  ${YELLOW}No official modules installed via LuaRocks${NC}"
        fi
    else
        echo -e "  ${YELLOW}prosodyctl not available${NC}"
    fi
}

module_search() {
    local query="${1:-}"

    if [[ -z "$query" ]]; then
        log_error "Please provide a search term"
        echo "Usage: prosody-manager module search <query>"
        return 1
    fi

    log_info "Searching for modules matching: $query"
    echo

    # Search official LuaRocks repository
    echo -e "${BOLD}Official Repository (LuaRocks):${NC}"
    if command_exists luarocks; then
        if run_in_container luarocks search --porcelain "$query" 2>/dev/null | grep -q "mod_"; then
            run_in_container luarocks search --porcelain "$query" 2>/dev/null | grep "mod_" | while read -r name version repo; do
                echo -e "  ${BLUE}$name${NC} ${CYAN}($version)${NC} - Install with: ${GREEN}prosody-manager module rocks install $name${NC}"
            done
        else
            echo -e "  ${YELLOW}No official modules found${NC}"
        fi
    else
        echo -e "  ${YELLOW}LuaRocks not available${NC}"
    fi

    echo

    # Search community repository
    echo -e "${BOLD}Community Repository (prosody-modules):${NC}"

    # Clone or update the modules repository
    if [[ ! -d "$TEMP_MODULES_DIR" ]]; then
        log_info "Downloading modules repository..."
        hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" >/dev/null 2>&1
    else
        log_info "Updating modules repository..."
        (cd "$TEMP_MODULES_DIR" && hg pull -u >/dev/null 2>&1)
    fi

    local count=0
    for module_dir in "$TEMP_MODULES_DIR"/mod_*; do
        if [[ -d "$module_dir" ]]; then
            local module_name
            module_name=$(basename "$module_dir")
            if [[ "$module_name" == *"$query"* ]]; then
                local installed=""
                if [[ -d "$MODULES_DIR/$module_name" ]]; then
                    installed=" ${GREEN}(installed)${NC}"
                fi
                echo -e "  ${CYAN}$module_name${NC}$installed - Install with: ${GREEN}prosody-manager module install $module_name${NC}"

                # Show description if available
                local readme="$module_dir/README.markdown"
                if [[ -f "$readme" ]]; then
                    local desc
                    desc=$(head -n 5 "$readme" | grep -E "^[A-Z].*" | head -n 1 | cut -c1-80)
                    if [[ -n "$desc" ]]; then
                        echo -e "    ${desc}..."
                    fi
                fi
                ((count++))
            fi
        fi
    done

    if [[ $count -eq 0 ]]; then
        echo -e "  ${YELLOW}No community modules found${NC}"
    fi

    echo
    log_info "💡 Tip: Use 'prosody-manager module rocks install <name>' for official modules with dependency handling"
    log_info "💡 Tip: Use 'prosody-manager module install <name>' for community modules (manual dependency management)"
}

module_install() {
    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        log_error "Please provide a module name"
        echo "Usage: prosody-manager module install <module_name>"
        echo "  For official modules with dependencies: prosody-manager module rocks install <module_name>"
        return 1
    fi

    # Add mod_ prefix if not present
    if [[ "$module_name" != mod_* ]]; then
        module_name="mod_$module_name"
    fi

    log_info "Installing community module: $module_name"

    # Check if already installed
    if [[ -d "$MODULES_DIR/$module_name" ]]; then
        log_warn "Module $module_name is already installed"
        read -p "Overwrite? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Installation cancelled"
            return 0
        fi
    fi

    # Clone or update the modules repository
    if [[ ! -d "$TEMP_MODULES_DIR" ]]; then
        log_info "Downloading modules repository..."
        hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" >/dev/null 2>&1
    fi

    local source_dir="$TEMP_MODULES_DIR/$module_name"
    if [[ ! -d "$source_dir" ]]; then
        log_error "Module not found: $module_name"
        log_info "Use 'prosody-manager module search <term>' to find available modules"
        return 1
    fi

    # Create modules directory if it doesn't exist
    run_in_container mkdir -p "$MODULES_DIR"

    # Copy module files
    if is_docker_environment; then
        cp -r "$source_dir" "$MODULES_DIR/"
        chown -R prosody:prosody "$MODULES_DIR/$module_name" 2>/dev/null || true
    else
        docker cp "$source_dir" "$(get_container_name):$MODULES_DIR/"
        run_in_container chown -R prosody:prosody "$MODULES_DIR/$module_name"
    fi

    log_success "Community module $module_name installed successfully"
    log_warn "⚠️  This is a community module - check dependencies manually!"
    log_info "📖 Read the module documentation for setup instructions"
    log_info "🔧 Add '$module_name' to your modules_enabled list and reload Prosody"
}

module_rocks() {
    local subcmd="${1:-help}"
    shift || true

    case "$subcmd" in
    "install")
        local module_name="${1:-}"
        if [[ -z "$module_name" ]]; then
            log_error "Please provide a module name"
            echo "Usage: prosody-manager module rocks install <module_name>"
            return 1
        fi

        log_info "Installing official module via LuaRocks: $module_name"
        if run_in_container prosodyctl install "$module_name"; then
            log_success "Official module $module_name installed successfully"
            log_info "✅ Dependencies handled automatically by LuaRocks"
            log_info "🔧 Add '$module_name' to your modules_enabled list and reload Prosody"
        else
            log_error "Failed to install $module_name via prosodyctl"
            log_info "💡 Try: prosody-manager module install $module_name (for community modules)"
        fi
        ;;
    "list")
        run_in_container prosodyctl list "$@"
        ;;
    "remove")
        local module_name="${1:-}"
        if [[ -z "$module_name" ]]; then
            log_error "Please provide a module name"
            echo "Usage: prosody-manager module rocks remove <module_name>"
            return 1
        fi

        log_info "Removing official module: $module_name"
        run_in_container prosodyctl remove "$module_name"
        ;;
    "outdated")
        run_in_container prosodyctl list --outdated
        ;;
    "help")
        echo -e "${BOLD}Official Module Management (LuaRocks)${NC}"
        echo
        echo -e "${GREEN}install <module>${NC}    Install official module with dependencies"
        echo -e "${GREEN}remove <module>${NC}     Remove official module"
        echo -e "${GREEN}list${NC}               List installed official modules"
        echo -e "${GREEN}outdated${NC}           List outdated official modules"
        ;;
    *)
        log_error "Unknown rocks subcommand: $subcmd"
        module_rocks help
        return 1
        ;;
    esac
}

module_remove() {
    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        log_error "Please provide a module name"
        echo "Usage: prosody-manager module remove <module_name>"
        echo "  For official modules: prosody-manager module rocks remove <module_name>"
        return 1
    fi

    # Add mod_ prefix if not present
    if [[ "$module_name" != mod_* ]]; then
        module_name="mod_$module_name"
    fi

    local module_path="$MODULES_DIR/$module_name"

    # Check if it's a community module
    if run_in_container test -d "$module_path"; then
        log_warn "This will remove community module: $module_name"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Removal cancelled"
            return 0
        fi

        run_in_container rm -rf "$module_path"
        log_success "Community module $module_name removed successfully"
    else
        log_error "Community module not found: $module_name"
        log_info "💡 For official modules, use: prosody-manager module rocks remove $module_name"
        return 1
    fi

    log_info "🔧 Remove '$module_name' from your modules_enabled list and reload Prosody"
}

module_update() {
    local module_name="${1:-}"

    if [[ -n "$module_name" ]]; then
        # Update specific community module
        if [[ "$module_name" != mod_* ]]; then
            module_name="mod_$module_name"
        fi

        if [[ ! -d "$MODULES_DIR/$module_name" ]]; then
            log_error "Community module not installed: $module_name"
            return 1
        fi

        log_info "Updating community module: $module_name"
        module_install "$module_name"
    else
        # Update all modules
        log_info "Updating all modules..."

        # Update community modules
        if [[ -d "$MODULES_DIR" ]]; then
            local count=0
            echo -e "${BOLD}Updating community modules:${NC}"
            for module_dir in "$MODULES_DIR"/mod_*; do
                if [[ -d "$module_dir" ]]; then
                    local module_name
                    module_name=$(basename "$module_dir")
                    log_info "Updating $module_name..."
                    module_install "$module_name"
                    ((count++))
                fi
            done
            echo -e "${GREEN}Updated $count community module(s)${NC}"
        fi

        # Update official modules
        echo -e "${BOLD}Updating official modules:${NC}"
        if run_in_container prosodyctl list --outdated 2>/dev/null | grep -q "mod_"; then
            run_in_container prosodyctl list --outdated 2>/dev/null | grep "mod_" | while read -r module_info; do
                local module_name
                module_name=$(echo "$module_info" | awk '{print $1}')
                log_info "Updating official module: $module_name"
                run_in_container prosodyctl install "$module_name"
            done
        else
            log_info "All official modules are up to date"
        fi
    fi
}

module_info() {
    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        log_error "Please provide a module name"
        echo "Usage: prosody-manager module info <module_name>"
        return 1
    fi

    # Add mod_ prefix if not present
    if [[ "$module_name" != mod_* ]]; then
        module_name="mod_$module_name"
    fi

    log_info "Module information: $module_name"

    # Check if installed as community module
    local installed_path="$MODULES_DIR/$module_name"
    if run_in_container test -d "$installed_path"; then
        echo -e "  ${GREEN}Status:${NC} Installed (Community)"
        echo -e "  ${GREEN}Path:${NC} $installed_path"

        # Show files
        echo -e "  ${GREEN}Files:${NC}"
        run_in_container find "$installed_path" -type f -name "*.lua" | head -10 | while read -r file; do
            echo "    $(basename "$file")"
        done
    else
        echo -e "  ${YELLOW}Community Status:${NC} Not installed"
    fi

    # Check if installed as official module
    if run_in_container prosodyctl list 2>/dev/null | grep -q "$module_name"; then
        echo -e "  ${BLUE}Official Status:${NC} Installed via LuaRocks"
    else
        echo -e "  ${YELLOW}Official Status:${NC} Not installed"
    fi

    # Get info from community repository
    if [[ ! -d "$TEMP_MODULES_DIR" ]]; then
        hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" >/dev/null 2>&1
    fi

    local repo_path="$TEMP_MODULES_DIR/$module_name"
    if [[ -d "$repo_path" ]]; then
        echo -e "  ${GREEN}Community Available:${NC} Yes"

        # Show README if available
        local readme="$repo_path/README.markdown"
        if [[ -f "$readme" ]]; then
            echo -e "  ${GREEN}Description:${NC}"
            head -n 10 "$readme" | sed 's/^/    /'
        fi
    else
        echo -e "  ${YELLOW}Community Available:${NC} No"
    fi

    # Check if available in official repository
    if run_in_container luarocks search --porcelain "$module_name" 2>/dev/null | grep -q "$module_name"; then
        echo -e "  ${BLUE}Official Available:${NC} Yes (via LuaRocks)"
        echo -e "  ${BLUE}Install Command:${NC} prosody-manager module rocks install $module_name"
    else
        echo -e "  ${YELLOW}Official Available:${NC} No"
    fi
}

module_sync() {
    log_info "Synchronizing community modules repository..."

    if [[ -d "$TEMP_MODULES_DIR" ]]; then
        rm -rf "$TEMP_MODULES_DIR"
    fi

    hg clone "$MODULES_REPO" "$TEMP_MODULES_DIR" >/dev/null 2>&1
    log_success "Community modules repository synchronized"

    # Also update LuaRocks cache
    log_info "Updating LuaRocks cache..."
    run_in_container luarocks list --outdated >/dev/null 2>&1 || true
    log_success "LuaRocks cache updated"
}

module_help() {
    echo -e "${BOLD}Module Management Commands${NC}"
    echo
    echo -e "${BOLD}OVERVIEW:${NC}"
    echo "  Two types of modules are supported:"
    echo -e "  ${BLUE}• Official modules${NC} - Installed via LuaRocks with automatic dependency handling"
    echo -e "  ${CYAN}• Community modules${NC} - Installed from prosody-modules repository (manual dependencies)"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager module <subcommand> [options]"
    echo
    echo -e "${BOLD}GENERAL COMMANDS:${NC}"
    echo -e "    ${GREEN}list [filter]${NC}           List all installed modules"
    echo -e "    ${GREEN}search <query>${NC}          Search both official and community modules"
    echo -e "    ${GREEN}info <module>${NC}           Show detailed module information"
    echo -e "    ${GREEN}update [module]${NC}         Update module(s)"
    echo -e "    ${GREEN}sync${NC}                    Sync module repositories"
    echo
    echo -e "${BOLD}COMMUNITY MODULES (prosody-modules):${NC}"
    echo -e "    ${GREEN}install <module>${NC}        Install community module (manual dependencies)"
    echo -e "    ${GREEN}remove <module>${NC}         Remove community module"
    echo
    echo -e "${BOLD}OFFICIAL MODULES (LuaRocks):${NC}"
    echo -e "    ${GREEN}rocks install <module>${NC}  Install official module with dependencies"
    echo -e "    ${GREEN}rocks remove <module>${NC}   Remove official module"
    echo -e "    ${GREEN}rocks list${NC}              List official modules only"
    echo -e "    ${GREEN}rocks outdated${NC}          List outdated official modules"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    # Search for modules"
    echo "    prosody-manager module search cloud"
    echo
    echo "    # Install official module (recommended for production)"
    echo "    prosody-manager module rocks install mod_cloud_notify"
    echo
    echo "    # Install community module (bleeding edge)"
    echo "    prosody-manager module install mod_pastebin"
    echo
    echo "    # List all modules"
    echo "    prosody-manager module list"
    echo
    echo "    # Update all modules"
    echo "    prosody-manager module update"
    echo
    echo -e "${BOLD}RECOMMENDATIONS:${NC}"
    echo -e "  ${BLUE}• Production:${NC} Use 'rocks install' for official modules with dependency handling"
    echo -e "  ${CYAN}• Development:${NC} Use 'install' for latest community modules"
    echo -e "  ${YELLOW}• Always:${NC} Read module documentation before enabling"
}

# ============================================================================
# MAIN COMMAND DISPATCHER
# ============================================================================

show_help() {
    echo -e "${BOLD}Prosody Manager v${VERSION}${NC}"
    echo "Unified CLI tool for Prosody XMPP Server management"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "    prosody-manager <command> [subcommand] [options]"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "    ${GREEN}prosodyctl${NC}     Prosody control commands"
    echo "        adduser <user@domain> [password]    Add user account"
    echo "        deluser <user@domain>               Delete user account"
    echo "        passwd <user@domain> [password]     Change user password"
    echo "        status                              Show Prosody status"
    echo "        reload                              Reload configuration"
    echo "        restart                             Restart Prosody service"
    echo "        cert <list|import|generate>         Certificate management"
    echo
    echo -e "    ${GREEN}health${NC}          Health monitoring"
    echo "        [process|ports|config|certs|all]    Run health checks"
    echo
    echo -e "    ${GREEN}cert${NC}            Certificate management"
    echo "        check <domain>                      Check certificate status"
    echo "        install <domain> [cert_path]        Install certificate"
    echo "        renew <domain>                      Renew certificate"
    echo
    echo -e "    ${GREEN}backup${NC}          Backup management"
    echo "        create [name]                       Create backup"
    echo "        restore <backup_file>               Restore from backup"
    echo "        list                                List available backups"
    echo
    echo -e "    ${GREEN}deploy${NC}          Deployment management"
    echo "        up [minimal|full]                   Start services"
    echo "        down                                Stop services"
    echo "        restart [service]                   Restart services"
    echo "        logs [service]                      View logs"
    echo "        status                              Show service status"
    echo
    echo -e "    ${GREEN}module${NC}          Module management"
    echo "        list [filter]                       List installed modules"
    echo "        search <query>                      Search available modules"
    echo "        install <module>                    Install a module"
    echo "        remove <module>                     Remove a module"
    echo "        update [module]                     Update module(s)"
    echo "        info <module>                       Show module information"
    echo "        sync                                Sync modules repository"
    echo
    echo -e "    ${GREEN}help${NC}            Show this help message"
    echo -e "    ${GREEN}version${NC}         Show version information"
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    prosody-manager prosodyctl adduser alice@atl.chat"
    echo "    prosody-manager health all"
    echo "    prosody-manager cert check atl.chat"
    echo "    prosody-manager backup create"
    echo "    prosody-manager deploy up full"
    echo "    prosody-manager deploy logs prosody"
    echo
    echo -e "${BOLD}ENVIRONMENT VARIABLES:${NC}"
    echo "    DEBUG=true                              Enable debug output"
    echo "    PROSODY_DOMAIN                          Default domain for operations"
    echo "    BACKUP_DIR                              Custom backup directory"
    echo
    echo "For more information, visit: https://github.com/allthingslinux/xmpp.atl.chat"
}

show_version() {
    echo "Prosody Manager v${VERSION}"
}

main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
    "prosodyctl")
        prosodyctl_command "$@"
        ;;
    "health")
        health_check "$@"
        ;;
    "cert" | "certificate" | "certificates")
        cert_command "$@"
        ;;
    "backup")
        backup_command "$@"
        ;;
    "deploy")
        deploy_command "$@"
        ;;
    "module")
        module_command "$@"
        ;;
    "help" | "-h" | "--help")
        show_help
        ;;
    "version" | "-v" | "--version")
        show_version
        ;;
    *)
        log_error "Unknown command: $command"
        echo
        show_help
        exit 1
        ;;
    esac
}

# Run main function with all arguments
main "$@"
